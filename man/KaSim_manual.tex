\documentclass[11pt]{book}
\frenchspacing
\usepackage{geometry}

\usepackage[parfill]{parskip}
\usepackage{graphicx}
\usepackage{amssymb}

\usepackage[T1]{fontenc}
\usepackage{textcomp}

%% LaTeX - Article customise

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{amsmath}

\usepackage[svgnames]{xcolor}
\usepackage{listings}
\usepackage{xypic}
\input{Kappa_LaTeX_Lang}

\usepackage[linktoc=page,colorlinks=true]{hyperref}
\expandafter\let\csname NR:Type\endcsname\relax

\usepackage{makeidx}
\usepackage{color}

\def\KaSimLogo{img/KaSim-Logo.pdf}

\usepackage{fancyhdr} %to insert logo on the left head of each page
\pagestyle{fancy}
\begin{titlepage}
\rhead{\includegraphics[width=35mm]{\KaSimLogo}}
\end{titlepage}

\def\Kappa{\textsc{Kappa}}
\def\KaSim{\textsf{KaSim}}
\def\KaSa{\textsf{KaSa}}
\def\KaDE{\textsf{KaDE}}
\def\sep{\hbox{-}}
\def\tcb#1{\textcolor{blue}{\ttt{#1}}}
\def\ttt#1{\texttt{#1}}
\def\var#1{{\textquotesingle}#1{\textquotesingle}}
\def\ignore#1{}
\makeindex

%% END Article customise

%%%% added by Vincent to compensate for the lack of mystyle.sty
\frenchspacing
\def\rar{\rightarrow}
\def\lrar{\leftrightarrow}

\def\ka{\kappa}
\def\ga{\gamma}
\def\bs{\backslash}
\def\noi{\noindent}
\def\ie{i.e.~}
\def\eg{e.g.~}
\def\via{via }
\def\set#1{\{#1\}}
\def\ITE#1{\begin{itemize}#1\end{itemize}}
\def\ENU#1{\begin{enumerate}#1\end{enumerate}}
\def\mit#1{{\mathit #1}}
\def\Real{\mathbb R}
\def\Nat{\mathbb N}
\def\Z{\mathbb Z}
\def\dd{-\hspace{0.001cm}-}
\def\imp#1{\emph{#1}\index{#1}}
%%%%

\newcommand{\Remark}{\paragraph{Remark}}

\input{generated_img/version}

\title{Kappa tools reference manual\\ \small (release \version)}
\author{Pierre Boutillier, J\'er\^ome Feret, Jean Krivine\thanks{corresponding author: jean.krivine@irif.fr}, Antoine Pouille and L\'y Kim Quy\^en \\\href{http://www.kappalanguage.org}{KappaLanguage.org}}

\date{}
                                    % Activate to display a given date or no date
\begin{document}
\maketitle

%\begin{center}\includegraphics[width=80mm]{img/wip.jpg}
%\vspace{3cm}
%\\This document is work in progress...
%\end{center}

\tableofcontents
\listoftables

\chapter{Introduction}
\begin{center}\includegraphics[width=9cm]{\KaSimLogo}\end{center}

\section{Support}
\ITE{
\item[-] Kappa language tutorials and downloads: \url{http://kappalanguage.org}
\item[-] Bug reports should be posted on github: \url{https://github.com/Kappa-Dev/KaSim/issues}
\item[-] Questions and answers on the Kappa-user mailing list: \url{http://groups.google.com/group/kappa-users}
\item[-] Want to contribute to the project? \ttt{jean.krivine@irif.fr}
}

\section{Preamble}
This manual describes the \Kappa{} language and details the usage of its
tool suite.

\Kappa{} is one member of the growing family of rule-based
languages. Rule-based modelling has attracted recent attention in
developing biological models that are concise, comprehensible, easily
extensible, and allows one to deal with the combinatorial complexity
of multi-state and multi-component biological molecules.

From the description of a system by the definition of a set of
entities and the enumeration of their \emph{local} rule of
interraction, \Kappa{} tools provide a framework to study statically and
dynamically the system without ever enumerating all its reachable states
(unless very explicitely asked to by users).

%Quyen: .. the system without enumerating all ... (unless it is asked by users)

In \Kappa{}, a mixture of entities is represented as a site graphs and
temporal local transformations as rewrites.

% TODO pirbo: put a lot of links in the paragraph
First contact with \Kappa{} as well as interactive model developement
could occurs in the \texttt{Kappapp} available online and as
downloadable software on main platforms. Intensive scientific usage
should occurs by scripting around the command line tools or by using the
Python client.

%Quyen: \Kappa{} available online in the \texttt{Kappapp}, as well as its interactive model
% developement. One can download the software on the main platforms.

After a small teaser, this manual provides an exhaustive list of what
can be done and how with the tools. \emph{It is not intended as a
  tutorial on rule-based modelling.}

%Quyen: This manual provides an exhaustive list of what and how to use the tools

% TODO pirbo: move that somewhere else (maybe a ``success story'' chapter)
To get an idea of how Kappa is used in a modelling context, the reader
can consult the following note
\href{http://www.research.ed.ac.uk/portal/files/16869853/Agile_Modelling_of_Cellular_Signalling_Invited_Paper_.pdf}{Agile
  modelling of cellular signalling (SOS'08)}. A longer article,
expounding on causal analysis is also available:
\href{http://fontana.med.harvard.edu/www/Documents/WF/Papers/signaling.causality.pdf}{Rule-based
  modelling of cellular signalling (CONCUR'07)}. See also this
tutorial:
\href{https://hal.archives-ouvertes.fr/hal-00692430}{Modelling
  epigenetic information maintenance: a Kappa tutorial}.

%Quyen:
%To get an idea of how Kappa is used in a modelling context, user
%can consult by the following note ..

\section{Show me a running example}\label{chap:abc}
See it really running in the online user interface by clicking on the
\emph{try} button on \url{https://www.kappalanguage.org/}.

%Quyen:To load the online user interface by chosing the
%\emph{try} button on \url{https://www.kappalanguage.org/}.

A minimal \Kappa model looks like:

% Quyen:A minimal \Kappa model is described as follow:
%agent: B(x)               // Declaration of agent B
%agent: C(x1{u p}, x2{u p}) // Declaration of agent C with 2 modifiable sites
%'ab.c' A(x[_],c[.]),C(x1{u}[.]) -> A(x[_] c[2]),C(x1{u}[2]) @ 'on_rate' //AB binds unphosphorilated C
%'mod x1' C(x1{u}[1]),A(c[1]) -> C(x1{p}[.]),A(c[.]) @ 'mod_rate'        //ABC modifies x1
%'a.c' A(x[.],c[.]), C(x1{p}[.], x2{u}[.]) ->
%      A(x[.],c[1]), C(x1{p][.], x2{u}[1]) @ 'on_rate'    //A binds x1_phos C on x2
%'mod x2' A(x[.], c[1]),C(x1{p}[.], x2{u}[1]) ->
%         A(x[.], c[.]),C(x1{p}[.], x2{p}[.]) @ mod_rate  //AC modifies x2

%obs: 'AB'  |A(x[x.B])|
%obs: 'Cuu' |C(x1{u}, x2{u})|
%obs: 'Cpu' |C(x1{p}, x2{u})|
%obs: 'Cpp' |C(x1{p}, x2{p})|
%/*Initial conditions */
%init: 1000  A(),B()
%init: 10000 C(x1{u}, x2{u})


\begin{lstlisting}[language=kappa]
/* Signatures*/
%agent: A(x, c)             // Declaration of agent A
%agent: B(x)               // Declaration of agent B
%agent: C(x1{u p}, x2{u p}) // Declaration of agent C with 2 modifiable sites
/* Variables */
%var: 'on_rate'  1.0E-4 // per molecule per second
%var: 'off_rate' 0.1    // per second
%var: 'mod_rate' 1      // per second
/* Rules */
'a.b' A(x[.]),B(x[.]) <-> A(x[1]),B(x[1]) @ 'on_rate', 'off_rate'       //A and B bind and dissociate
'ab.c' A(x[_], c[.]),C(x1{u}[.]) -> A(x[_], c[2]),C(x1{u}[2]) @ 'on_rate' //AB binds unphosphorilated C
'mod x1' C(x1{u}[1]),A(c[1]) -> C(x1{p}[.]),A(c[.]) @ 'mod_rate'        //ABC modifies x1
'a.c' A(x[.],c[.]), C(x1{p}[.], x2{u}[.]) ->
      A(x[.],c[1]), C(x1{p][.], x2{u}[1]) @ 'on_rate'    //A binds x1_phos C on x2
'mod x2' A(x[.], c[1]),C(x1{p}[.], x2{u}[1]) ->
         A(x[.], c[.]),C(x1{p}[.], x2{p}[.]) @ mod_rate  //AC modifies x2
/* Observation */
%obs: 'AB'  |A(x[x.B])|
%obs: 'Cuu' |C(x1{u}, x2{u})|
%obs: 'Cpu' |C(x1{p}, x2{u})|
%obs: 'Cpp' |C(x1{p}, x2{p})|
/*Initial conditions */
%init: 1000  A(),B()
%init: 10000 C(x1{u}, x2{u})
\end{lstlisting}

Lines 1-4 of this kappa file\index{Kappa file} contain
signature\index{agent signature}
declarations\index{signature}\index{declaration}. Agents of type
\ttt{C} have two sites \ttt{x1} and \ttt{x2} whose internal state may
be \ttt{u} (unphosphorylated) or \ttt{p} (phosphorylated).
%Recall that the default state of these sites is \ttt{u} (the first one).
Line 11, rule \ttt{{\textquotesingle}ab.c{\textquotesingle}} binds an
\ttt{A} connected to someone on site \ttt{x} to a \ttt{C}.

%Quyen:It is not line 8. It is line 11

%Note that the only rule that binds an agent to \ttt{x} of \ttt{A} is
%\ttt{{\textquotesingle}a.b{\textquotesingle}} at line 6. Hence the
%use of \ttt{!\_} is a commodity and the rule could be replaced
%by \begin{lstlisting}[language=kappa] 'alt_ab.c'
%A(x!1,c),B(x!1),C(x1~u) -> ...  \end{lstlisting}
There are two main points to notice about this model: \ttt{A} can
modify both sites of \ttt{C} once it is bound to them. However, only
an \ttt{A} bound to a \ttt{B} can connect on \ttt{x1} and only a free
\ttt{A} can connect on \ttt{x2}. Note also that \ttt{x2} is available
for connection only when \ttt{x1} is already modified.

%Quyen: There are two main remarks about this model:...

%\subsection{Some runs}
We try first a coarse simulation of $100,000$ events (10 times the
number of agents in the initial system).

\ttt{ \ITE{
\item[\$] KaSim ABC.ka -u event -l 100000 -p 1000 -o abc.csv
}}

Plotting the content of the \ttt{abc.csv} file, one notices that
nothing significantly interesting happens to the observables after
250s. So we can now specify a meaningful time limit by running:

\ttt{
\ITE{
\item[\$] KaSim ABC.ka -l 250 -p 0.25 -o abc.out
}}

which produces the data points whose rendering is given in Fig.~\ref{fig:abc}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=12cm]{generated_img/plot-abc.pdf}
\caption{Simulation of the ABC model: population of unmodified
  \ttt{C}s (in red is the observable \ttt{Cuu}) drops rapidly and is
  replaced, in a first step by simply modified \ttt{C}s (in blue is the observable
  \ttt{Cpu}) which are in turn replaced by doubly modified
  \ttt{C}s (in red is the observable \ttt{Cpp}). Note that, the population of
  \ttt{AB} complexes (observable \ttt{AB} in black) stabilizes
  slightly below 400 individuals after about 20s.}
\label{fig:abc}
\end{center}
\end{figure}

We will use variant of this model as a running example for the next chapter.

\chapter{The Kappa language}\label{chap:kappa}

\section{General structure}
A model is represented in Kappa by a set of \emph{Kappa Files}. We use
KF\index{Kappa file} to denote the union of the files that are given
as input to a tool.

A KF\index{Kappa file} is composed of a list of
\emph{declaration}\index{declaration}.
Declarations can be: agent and token \emph{signatures}
(Sec.~\ref{sec:sig}), \emph{rules}\index{rule} (Sec.~\ref{sec:rules}),
\emph{variables}\index{variable} (Sec.~\ref{sec:var}), \emph{initial
  conditions}\index{initial condition} (Sec.~\ref{sec:init}),
\emph{intervention}\index{intervention} (Sec.~\ref{sec:mod}) and
\emph{parameter configurations} (Sec.~\ref{sec:param}).

The KF\index{Kappa file}'s structure is quite flexible. Neither
dividing into several sub-files nor the order of
declaration\index{declaration}s matters (for the exception of
interventions and variable declaration\index{declaration}s, see
respectively Sections \ref{sec:mod} and \ref{sec:var} for details).

Comments\index{comments} works like in the C language. It can be used
either by inserting the marker \ttt{//} that tells \KaSim~to ignore
the rest of the line or by putting any text between the delimiters
\ttt{/*} and \ttt{*/}.

% TODO pirbo: better
The following sections present formal grammars. Here are hints to read
them.  Terminal symbols are written in (blue) typed font, and
$\varepsilon$ stands for the empty list. An identifier \ttt{Id} can be
any string generated by a regular expression of the type
$\_\ [a\sep z\ A \sep Z\ 0\sep 9\ \_\ -\ +]^+ |
[ a\sep z\ A\sep Z][a\sep z\ A \sep Z\ 0\sep 9\ \_\ -\ +]^*$.

\section{Site graph pattern: Kappa expression}

The state of the system is represented in Kappa as a site graph: a
graph where edges use sites in nodes. One must think sites as
resources. At most one edge of the graph can use a site of a node
(representing an agent in our case). Moreover, all the sites of an
agent must have different names.

This leads to the property that an embedding between 2 site graphs is
completely defined by the image of one node. This is absolutely
critical for the efficiency and we call this concept the
\emph{rigidity of \Kappa{}}.

\begin{table}[ht!]
  \centering
  \caption{Kappa expressions.}
  \begin{tabular}{@{} lcl @{}}
    \textit{Kappa\_expression} & ::= & \textit{agent\_expression} \tcb{,} \textit{Kappa\_expression} $\mid\varepsilon$ \\
    \textit{agent\_expression} & ::= &  \tcb{Id}\tcb{(}\textit{interface}\tcb{)} \\
    \textit{interface} &::=& \tcb{Id} \textit{internal\_state link\_state}  \tcb{,} \textit{interface} $\mid\varepsilon$ \\
    \textit{internal\_state} &::=& $\varepsilon$ | \tcb{\{.\}} | \tcb{\{Id\}} \\
    \textit{link\_state} &::=& $\varepsilon$ | \tcb{[.]} | \tcb{[n]} | \tcb{[\_]} | \tcb{[\#]}  | \tcb{[Id.Id]} \\
    \end{tabular}
  \label{tab:patterns}
\end{table}

\subsection{Graphs}
The ASCII syntax we use to represent site graphs follows the
skeletons (describe formally in Table \ref{tab:patterns}):
\begin{itemize}
\item We write the type of the agent and then its interface (the
  space-separated list of its sites) between parenthesis.
\item The state of a site is written after its name. Sites can have 2
  kind of states: a linking state and an internal state. The order in
  which they are specified does not matter.
\item The linking state of a site is written in between squared
  brackets: \ttt{[]}
\item The internal state of a site is written in between curly
  brackets: \ttt{\{\}}
\item When the site is \emph{free} ({\ie}it is not a member of an
  edge), its linking state is written with a dot: \ttt{[.]}. For example,
  the following graph:
  \begin{center}
    \includegraphics{gkappa_img/syntax_agent.pdf}
  \end{center}
  is written as \ttt{A(x[.], y\{p\}[.], z\{e0\}[.])}.
\item When a site is a part of an edge, one assign an arbitrary
  positive integer identifier $n$ to this edge and one specify the
  appurtenance of the site to this edge by writing the linking state
  \ttt{[n]}. The following graph:
  \begin{center}
    \includegraphics{gkappa_img/syntax_ring.pdf}
  \end{center}
  can be reprensented as \ttt{A(x[23], y[4]\{u\}, z\{e1\}[.])},
  \ttt{A(x[4], y\{u\}[95], z\{e1\}[.])},
  \ttt{A(x[95], y\{u\}[23], z\{e1\}[.])}.

  \Remark{Each link identifier appears exactly twice.}
\end{itemize}

\subsection{Patterns}
\Kappa{} strength is to describe transformations by only mentioning (and
storing) the relevant part of the subgraph required for that
transformation to be possible. This is the \emph{don't care, don't
  write} (DCDW)\index{don't care don't write} principle which plays a
key role in resisting combinatorial explosion when writing models.

If a transformation occurs independently from the state of a site of
an agent, do not mention it in the \emph{pattern} to match. The pattern
A(x[.],z[.]) represents an agent of type A whose sites x and z are
free but the sites y and z can be in any internal state and the site y
can be linked or not to anything.

If the link state of a site does not matter but the internal state
does, just mention it. An agent A whose sites x and z are free, y
is in state u and z in state e2 is written as
A(x[.],y\{u\},z\{e2\}[.]).

A state that is modified (by a rule that will be presented just below)
always matter. For such situation, the symbol \ttt{\#} (meaning
``whatever'' state) has been introduced.

\subsection{Link type}

In \Kappa{}, in order to require a site to be bound for an
interaction to occur, one may use the
\emph{semi-link}\index{semi-link} construct \ttt{[\_]} which does not
specify who the partner of the bond is. For instance, in the following
instruction: \lstinline[language=kappa]*%var: 'ab' |A(x[_]),B(y[_])|*,
the variable \var{ab} will count the number of \ttt{A}s and \ttt{B}s
connected to some agents, including the limit case
\ttt{A(x[1]),B(y[1])}. It is sometimes convenient to specify the
\emph{type}\index{link type} of the semi-link, in order to restrict
the choice of the binding partner. For instance, in the following
instruction: \lstinline[language=kappa]*%var: 'ab' |A(x[y.B]),B(y[x.A])|*,
the variable \var{ab} will count the number of
\ttt{A}s whose site \ttt{x} is connected to a site \ttt{y} of \ttt{B},
plus the number of \ttt{B}s whose site \ttt{y} is connected to a site
\ttt{x} of \ttt{A}. Note that, this still includes the case
\ttt{A(x[1]),B(y[1])}.

\Remark{Transformations on semi-links and links type induce side
  effects (effect on unmentioned agents/unmentioned site of agent) and
  can even do not make sense at all. What would mean to remove the link
  to A but not the link to B in the example above? Be careful when
  one use them.}

\section{Agent signatures}\index{agent signature}\label{sec:sig}
%
\Kappa{} tools can seek in the KF\index{Kappa file} what agents are
used, what sites they have and what states the sites are in but it
is error prone: just make a typo once and the tools won't complain and
create a nonsens new agent/site/states...

To avoid that, \emph{Agent signatures}\index{agent signature} can be
defined and tools will then ensure that agents respect their
signature.

Agent signatures list all the agents that will appear in the
KF\index{Kappa file}. They enumerate the name of interaction sites
an agent has. They provide information about sites binding capabilities.
They specify whether a site has internal state and if so give the possibilities.

A signature\index{agent signature} is declared in the
KF\index{Kappa file} by the following line: \ITE{
\item[] \ttt{\%agent: } \textit{signature\_expression} } according to
an extention of the grammar given in Table~\ref{tab:patterns}. Linking
states and internal states are space-separated lists instead of being
singleton. Site binding capabilities are specified by giving a list
typed semi-links.

For instance, the line:
\begin{lstlisting}[language=kappa]
%agent: A(x[y.A], y{u p}[x.A], z{e0 e1 e2}) // Signature of agent A
\end{lstlisting}
will declare an agent \ttt{A} with 3 \emph{(interaction) sites}
\ttt{x,y} and \ttt{z}, the site \ttt{y} possessing two \emph{internal
  states}\index{internal state} \ttt{u} and \ttt{p} (for instance, for
the unphosphorylated and phosphorylated forms of \ttt{y}) and the site
\ttt{z} having three possible states $e0$, $e1$ and $e2$, sites
\ttt{x} and sites \ttt{y} being able to bind (intra agent or inter
agents).

\paragraph{Special case} If no agent signature provides any site binding capabilities,
constraints are released and any site of any agent is allowed to bind
any site of any agent.

\section{Algebraic expressions, variables and observables}\label{sec:var}

Algebraic expressions\index{algebraic expression} original purpose was
to define kinetic rates\index{kinetic rate} for rules but many
components of a KF\index{Kappa file} will now implies algebraic
expressions. Their syntax are defined in Table~\ref{tab:alg}
(available symbols for variable, constants and operators are given in
Table~\ref{tab:operators}).

%%
\begin{table}[htbp]
  \centering
  \caption{Algebraic expressions.}
  \begin{tabular}{@{} lcl @{}}
    \textit{algebraic\_expression} & ::= & \tcb{$x\in\Real$} $\mid$ \tcb{variable} \\
     &  & $\mid$ \textit{algebraic\_expression} \tcb{binary\_op} \textit{algebraic\_expression}\\
     &  & $\mid$ \ tcb{unary\_op} \tcb{(}\textit{algebraic\_expression}\tcb{)} \\
     &  & $\mid$ \textit{boolean\_expression}  \ttt{[?]} \textit{algebraic\_expression} \\
     & & \hspace*{2cm} \ttt{[:]} \textit{algebraic\_expression}\\
  \end{tabular}
  \label{tab:alg}
  \end{table}
The last item of the list is an
if-expression. \textit{boolean\_expression} are described in
Table~\ref{tab:pert}. Think very carefully whether it is the correct
thing to do before using it. Mechanistic conditions have to be
expressed in rule bodies and not in rule rates!

%%

\begin{table}[htbp]
\centering
\caption{Symbols usable in algebraic expressions.%\index{algebraic expression}
}
\begin{tabular}{@{} l|l @{} }
\toprule
\ttt{\tcb{variable}} & Interpretation \\
\midrule
\ttt{[E]} & the total number of (productive) simulation events\index{event}\\
& since the beginning of the simulation \\
\ttt{[E-]} & the total number of null events\index{null event}\\
%\ttt{[Emax]} & the max (productive) event limit as set by \ttt{-l} (in \ttt{-u event} mode) \\ &(note that if unset \ttt{Emax}$=\infty$)\\
\ttt{[T]} & the bio-time of the simulation \\
\ttt{[Tsim]} & the cpu-time since the beginning of the simulation \\
%\ttt{[Tmax]} & the max (bio)-time limit as set by the option \ttt{-l} \\ &(note that if unset \ttt{Tmax}$=\infty$)\\
%\ttt{[pp]} & the number of requested plotting interval set by the option \ttt{-p} \\

\ttt{\var{v}} & the value of variable \ttt{\var{v}} (declared by using the \ttt{\%var:} statement) \\
\ttt{|t|} & the concentration of token \ref{sec:hybrid} \ttt{t}\\
\ttt{|\textit{Kappa\_expression}|} & number of occurences of the pattern \textit{Kappa\_expression}\\
\ttt{inf} & symbol for $\infty$ \\\\
\toprule
\ttt{\tcb{unary/binary\_op}} & Interpretation \\
\midrule
\ttt{[}$f$\texttt{]} & usual mathematical functions and constants \\ &with $f\in\set{\hbox{\ttt{log,exp,sin,cos,tan,sqrt,pi}}}$ \\
\ttt{[int]} & the floor function $x\in\Real\mapsto \lfloor x\rfloor\in\Z$ \\
\ttt{+,-,*,/,\textasciicircum} & basic mathematical operators (infix notation)\\
\ttt{[mod]} & the \emph{modulo} operator (infix notation)\\
\ttt{[max]} & the \emph{maximum} of two values \\
\ttt{[min]} & the \emph{minimum} of two values \\
%\ttt{[exp]} & the exponentiation operation $x\mapsto e^x$ \\
\bottomrule
\end{tabular}
\label{tab:operators}
\end{table}
%%

It is possible to declare
\emph{variables}\index{variable} for later use with the declaration: \ITE{
\item[] \ttt{\%var: \var{var\_name}~} (\textit{algebraic\_expression})
} where \ttt{var\_name} can be any string.  For instance, the
declaration\index{declaration}s
\begin{lstlisting}[language=kappa]
%var: 'homodimer' |A(x[1]),A(x[1])|
%var: 'aa' 'homodimer'/2
\end{lstlisting}
define two variables, the first one tracking the number of embeddings
of \ttt{A(x[1]),A(x[1])} in the graph over time, while the second
divides this value by 2: the number of automorphisms in
\ttt{A(x[1]),A(x[1])}. Note that variables that are used in the
expression of another variable must be declared beforehand.

More importantly, \KaSim~may output values of an algebraic expression
in the data file\index{data file} (see option \ttt{-p} in
Chapter~\ref{chap:cl}) by using the primitive
\begin{lstlisting}[language=kappa]
%plot: 'var_name'
\end{lstlisting}

One may use the shortcut:
\ITE{
\item[] \ttt{\%obs: {\textquotesingle}var\_name{\textquotesingle} }
  \textit{algebraic\_expression}} to declare a variable and at the
same time require it to be outputted in the data file\index{data
  file}.

\section{Rules}\label{sec:rules}

Dynamics of agents is described in the KF\index{Kappa file} by defining
rules\index{rule}.

There are two ways of specifying rules:
\begin{enumerate}
  \item following the chemical intuition (with the burden of a subtle
    before/after correspondance), by giving two {\it
      Kappa\_expression}s. The first one, called \emph{left hand
      side}\index{left hand side} (LHS), represents what one need to
    apply the rule. The second, the \emph{right hand side}\index{right
      hand side} (RHS), describes what one obtain once the rule is
    applied. In \Kappa{}, they are separated by an arrow $\rar$.
  \item by giving one {\it Kappa\_expression} with edition. The
    \Kappa{} expression still represents the necessary context for the
    rule to apply. Modifications are specified locally inside the
    expression right after tests.
\end{enumerate}

Both are allowed in \Kappa{} and are described in both next subsections.

In any case, rule specification is optionally prefixed by a rule name
(written between two symbols \textquotesingle) and always followed by
a rule rate.  Rate expressions (which are syntactically algebraic
expressions\index{algebraic expression}) are given by the grammars in
Table~\ref{tab:rates} and Table~\ref{tab:alg} (respectively) but can
be thought at first as positive real numbers.

A complete rule in the chemical representation looks like:

\ITE{
\item[] \ttt{{\textquotesingle}rule name{\textquotesingle} } {\it
  Kappa\_expression} $\rar$ {\it Kappa\_expression} \ttt{@} {\it rate}
}

One may also declare a \imp{bi-directional rule} in chemichal notation by
using the convention:

\ITE{
\item[] \ttt{{\textquotesingle}bi-rule{\textquotesingle}} {\it Kappa\_expression} $\lrar$ {\it Kappa\_expression} \ttt{@} {\it rate$^+$,rate$^-$}
}

The above declaration\index{declaration} is equivalent to write, in
addition to the rule named \ttt{\var{bi-rule}} and another rule named
\ttt{\var{bi-rule\_op}} which swaps left and right hand sides, and has
rate \textit{rate$^-$}.

\subsection{Chemical notation rules}\index{chemical notation}

This is the most intuitive representation. Nevertheless, it induces
duplication of the unmodified context between LHS and RHS which can
lead to even more errors when edition a posteriori on the left are not
correctly reported on the right.

\subsubsection*{A simple rule}
With the signature\index{agent signature} of \ttt{A} defined in Section \ref{sec:sig}, the line
\begin{lstlisting}[language=kappa]
'A dimerization' A(x[.]),A(y{p}[.]) -> A(x[1]),A(y{p}[1]) @ 'gamma'
\end{lstlisting}
declares a dimerization rule between two instances of agent \ttt{A}
provided the second agent is phosphorylated on site \ttt{y} (this is the meaning of \ttt{p}).

Remember that the identifier \ttt{[1]} of the bound is arbitrary and
that following DCDW\index{don't care don't write}, the site \ttt{z}
of \ttt{A} is not mentioned in the expression because it has no
influence on the triggering of this rule.

\subsubsection*{Degradation and synthesis}
In the RHS of a rule, the k-th agent must correspond to
the (transformed) k-th agent of the LHS.

If one want to create or delete agent, one must put a ghost agent
(written with a dot) at their corresponding place on the left/right
hand side of the rule.

Sticking with \ttt{A}'s signature\index{agent signature}, one can
express that an unphosphoralated \ttt{A} can collapse if not linked to
anyone (regardless of the state of z) by writing
\begin{lstlisting}[language=kappa]
'destroy A' A(x[.], y{u}[.], z[.]) -> . @ 'gamma'
\end{lstlisting}

Similarly, the rule
\begin{lstlisting}[language=kappa]
'building A' A(z[.]), . -> A(z[1]),A(x[1]) @ 'gamma'
\end{lstlisting}
indicates that an agent \ttt{A} is free on site \ttt{z}, no matter what
its internal state is, may beget a new copy of \ttt{A} bound to it
\via site \ttt{x}.

Note that in the RHS, the interface of the new copy is not completely
described. Following the DCDW convention\index{don't care don't
  write}, \KaSim~will assume that the sites that are not
mentioned are created in the \emph{default state}\index{default
  state}, {\ie}they appear free of any bond and their internal state
(if any) is the first of the list shown in the signature\index{agent
  signature} (here state \ttt{u} for \ttt{y} and \ttt{0} for \ttt{z}).

\subsubsection*{Side effects}\label{sec:side-effect}

It may happen that the application of a rule has some \emph{side
  effects}\index{side effect} on agents that are not mentioned
explicitly in the rule. Consider for instance the previous rule:
\begin{lstlisting}[language=kappa]
'deleting A' A(x[1]), A(z[1]) -> A(x[.]), . @ 'gamma'
\end{lstlisting}
The \ttt{A} in the graph that is matched to the second occurrence of
\ttt{A} in the LHS will be deleted by the rule. As a consequence, all
its sites will disappear together with the bonds that were pointing to
them. For instance, when applied to the following graph: \ITE{
\item[] $G=$\ttt{A(x[1],y\{p\}[.],z\{e2\}[.]), A(x[2], y\{u\}[.],
  z\{e0\}[1]), C(t[2])} } the above rule will result in a new graph
$G' =\ttt{A(x[1],y\{p\}[.],z\{e2\}[.]),C(t[.])}$ where the site
\ttt{t} of \ttt{C} is now free as side effect.

\emph{Whatever} symbols for link state \ttt{[\#]} (for whatever state
bound or not), \ttt{[\_]} (for bound to some site), may also induce
side effects when they are not preserved in the RHS of a rule, as in
\begin{lstlisting}[language=kappa]
'Disconnect A' A(x[_]) -> A(x[.]) @ 'gamma'
\end{lstlisting}
or
\begin{lstlisting}[language=kappa]
'Force bind A' A(x[#]),C(t[.]) -> A(x[1]),C(t[1]) @ 'gamma'
\end{lstlisting}
%%
To avoid mistakes, sites and states mentioned on the left must be
exactly the same as sites mentioned on the right. Use the explicit
``whatever'' \ttt{[\#]} state when needed.

\subsection{Edit notation rules}\index{edit rules}

Near any modified element, modification is specified. Created agents
are postfixed by a $+$. Degraded agents are postfixed by a $-$. Site
modifications are described by writing the new (linking or internal)
state after the symbol $/$ inside the (curly/squared)
bracket. Therefore, $/.$ (inside squared brackets) means that the site
becomes free, $/9$ means that the site becomes part of link $9$ and
$/zzz$ inside curly brackets means that the new internal state of the
site is $zzz$.

Here are all the rules mentioned above (+1 extra) translated in this
unambiguous notation:
\begin{lstlisting}[language=kappa]
'A dimerization' A(x[./1]),A(y{p}[./1]) @ 'gamma'
'destroy A' A(x, y{u}, z)- @ 'gamma'
'building A' A(z[./1]), A(x[1])+ @ 'gamma'
'deleting A' A(x[1/.]), A(z[1])- @ 'gamma'
'weird' A(z[1])-, A(x[1])-, A(x[.])+ @ 'gamma'
'Disconnect A' A(x[_/.]) @ 'gamma'
'Force bind A' A(x[#/1]), C(t[./1]) @ 'gamma'
'phos C' C(x1{u/p}[1/.]),A(c[1/.]) @ 'modrate'
\end{lstlisting}

\subsection{Rates}\label{sec:kinetics}
Kappa rules are equipped with one (or two) \emph{kinetic
  rate(s)}\index{kinetic rate}. A rate is an algebraic
expression\index{algebraic expression} (often simply a real
number) evaluated as such, called the \emph{individual-based or
  stochastic rate constant}\index{kinetic rate!stochastic rate
  constant}, it is the rate at which the corresponding rule is applied
per instance of the rule. Its dimension is the inverse of a time
$[T^{-1}]$.

The stochastic rate is related to the \emph{concentration-based rate
  constant}\index{kinetic rate!deterministic rate constant} $k$ of the
rule of interest by the following relation:
%corrected by the volume $V$ in which the model is considered.
%
%%We often want to express $\ga$ in {\textquotesingle}{\textquotesingle}per molecule{\textquotesingle}{\textquotesingle} rather than {\textquotesingle}{\textquotesingle}per mole{\textquotesingle}{\textquotesingle}.
%%This only changes the numerical value, not the dimension (both are numbers of molecules):
%
%%The relation between both rate constant is:
\begin{equation}\label{stochrate}
k = \ga{({\cal A}\; V)^{(a-1)}} %\qquad [\mathit{molecule}^{-1} \mathit{s}^{-1}],
\end{equation}
where
$V$ is the volume where the model is considered,
${\cal A}= 6.022\cdot 10^{23}$ is Avogadro' s number, %number of $H$ atoms needed to make up for a gram of $H$,
$a\geq0$ is the arity of the rule ({\ie}$2$ for a bimolecular rule).

In a modelling context, the constant $k$ is typically expressed using
\emph{molars} $M:=\mit{moles}\,l^{-1}$ (or variants thereof such as
$\mu M$, $nM$), and seconds or minutes. If we choose molars and
seconds, $k$' s unit is $\mathit{M}^{1-a}\mathit{s}^{-1}$, as follows
from the relation \ref{stochrate}.

Concentration-based rates are usually favoured for measurements and/or
deterministic models, so it is useful to know how to convert them into
individual-based ones used by KaSim.
%We refer the reader to \url{http://www.KappaLanguage.org} for a tutorial on kinetic rates.
Here are typical volumes used in modelling:
\begin{itemize}
\item Mammalian cell: $V=2.25\; 10^{-12}l$  ($1l=10^{-3}m^3$), and ${\cal A}V=1.35\; 10^{12}$.

A concentration of $1M$ in a mammalian cell volume corresponds to
$1.35\; 10^{12}$ molecules; $1nM\approx 1350$ molecules per cell.

\item
Yeast cell (haploid): $V=4\; 10^{-14}l$, and ${\cal A}V=2.4\; 10^{10}$.

A concentration of $1M$ in a yeast cell volume corresponds to $2.4\;
10^{10}$ molecules; $1nM\approx 24$ molecules per cell. The volume is
doubled in a diploid cell.
\item
E.\@ Coli cell: $V=10^{-15}l$, and ${\cal A}V=10^{8}$.

A concentration of $1M$ in a yeast cell volume corresponds to $10^{8}$
molecules; $10^{n}M\approx 1$ molecule per cell.
\end{itemize}

The table \ref{tab:kin_rates} lists typical ranges for deterministic
rate constants and their stochastic counterparts assuming a mammalian
cell volume.

\begin{table}[htbp]
\centering
\caption{Example of kinetic rates.}
\label{tab:kin_rates}
\begin{tabular}{@{} lllr @{} }
\toprule
process & $k$ & $\gamma$ %& stoch. dimension
\\
\midrule
general binding & $10^{7}-10^{9}$ & $10^{-5}-10^{-3}$ %& $s^{-1}$ %$molecule^{-1} s^{-1}$
\\
general unbinding &  $10^{-3} - 10^{-1}$ & $10^{-3}-10^{-1}$ %& $s^{-1}$
\\
dephosphorylation & 1 & 1 %& $s^{-1}$
\\
phosphorylation & 0.1 & 0.1 %& $s^{-1}$
\\
receptor dimerization & $2\; 10^{6}$ & $1.6 \;10^{-6}$ %& $s^{-1}$%$molecule^{-1} s^{-1}$
\\
receptor dissociation & $1.6\; 10^{-1}$ & $1.6\; 10^{-1}$ %& $s^{-1}$
\\
\bottomrule
\end{tabular}
\end{table}

\subsection{Ambiguous molecularity}\label{sec:ambiguous}

Using a Kappa rule of the form \ttt{A(x[.]),B(y[.])$\rar \dots$ @
  $\ga$} is not a good practice, where this rule could be applied in a
context where \ttt{A} and \ttt{B} are sometimes already connected and
sometimes disconnected. This would lead to an inconsistency in the
definition of the kinetic rate $\ga$ which should have a volume
dependency in the former case and be volume independent in the latter
case ({\eg}see Section~\ref{sec:kinetics}).

This sort of ambiguity should be resolved, if possible, by refining
the ambiguous rule into cases that are either exclusively unary or
binary. Each refinement having a kinetic rate that is consistent with
its molecularity. Note that in practice, for models having a large
number of agents, it is sufficient to assume that the rule
\ttt{A(x[.]),B(y[.])$\rar \dots$ @ $\ga$} will have only binary
instances. In this case, it suffices to consider the approximate model:
\begin{lstlisting}[language=kappa]
'assumed binary AB' A(x[.]),B(y[.]) -> ... @ 'ga_2'
'unary AB' A(x[.],c[1]),C(a[1],b[2]),B(y[.],c[2]) -> ... @ 'k_1'
\end{lstlisting}

There exist systems where enumerating unary cases becomes impossible
or where the approximation on binary instances is wrong. As an
alternative, one should use the Kappa notation for ambiguous rules:
\ITE{
\item[] \ttt{{\textquotesingle}my rule{\textquotesingle}} {\it
  Kappa\_expression} $\rar$ {\it Kappa\_expression} \ttt{@} $\ga_2
  \{k_1\}$ } which will tell \KaSim~to apply the rule named
\ttt{{\textquotesingle}my rule{\textquotesingle}} with a rate $\ga_2$
for binary instances and a rate $k_1$ for unary instances.

The obtained model will behave exactly as a model in which the
ambiguous rule has been replaced by unambiguous refinements. However
the usage of such rule \emph{slowdowns simulation in a significant
  manner} depending on various parameters (such as the presence of
large polymers in the model). We give below an example of a model
utilizing binary/unary rates for rules\footnote{This model is
  available in the source repository \ttt{examples/poly.ka}.}.

\lstinputlisting[language=kappa]{../examples/poly.ka}

Notice at lines 10-12 the use of binary/unary notation for rules. As a
result binding between freely floating agents will occur at rate
\ttt{{\textquotesingle}k2{\textquotesingle}} while binding between
agents that are part of the same complex will occur at rate
\ttt{{\textquotesingle}k1{\textquotesingle}}. Line 21 contains a
\emph{intervention} that requires \KaSim~to stop the simulation after
10,000 events and output the list of molecular species present in the
final mixture\index{mixture} as a \texttt{dot} file ({\eg}see Section~\ref{sec:mod})
that we give in Figure~\ref{fig:species}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=15cm]{generated_img/poly.png}
\caption{Final mixture %\index{mixture} obtained after 10,000 events
  of simulation of the \ttt{poly.ka} model. The infinite rate for
  cycle closure allows one to obtain a large number of triangles.}
\label{fig:species}
\end{center}
\end{figure}

For rules with unary rates, one can also specify a \emph{horizon}.
For example in the following rule:
\begin{lstlisting}[language=kappa]
'a.b' A(b[.]),B(a[.]) -> A(b[1]),B(a[1]) @ 'k2'{'k1':5}
\end{lstlisting}
the unary rate is applied only when the agents $A$ and $B$ are at a
horizon $5$ (or closer), of each other. Horizon is an algebraic
expression. It is always truncated to a positive integer during
simulation.  This feature \emph{can change in the future}.

\begin{table}[ht!]
  \centering
  \caption{Rate expressions.}
  \begin{tabular}{@{} lcl @{}}
    \textit{rate\_expression} &::=& \textit{algebraic\_expression} \\
&&| \textit{algebraic\_expression} \tcb{\{}\textit{algebraic\_expression}:\textit{algebraic\_expression}\tcb{\}}
    \end{tabular}
  \label{tab:rates}
\end{table}

\subsection{Hybrid rules}\label{sec:hybrid}
In \Kappa{}, there can be a special treatment of entities that cannot
bind anything: \emph{tokens}.  Tokens can only appear or disappear,
they are typically used to represent small particles such as ions,
ATP, etc.

Tokens may have a continuous concentration.

Token signature\index{agent signature}s are declared using a statement
of the form:
\begin{lstlisting}[language=kappa]
%token: ca+ # Signature of calcium token
\end{lstlisting}

It is possible to mix agents and tokens in \imp{hybrid rules} (which
may also be bi-directional). A hybrid rule has the following form:

\ITE{
\item[] {\it Kappa\_expression} | {\it token\_expression} $\rar$ {\it Kappa\_expression}  | {\it token\_expression }\ttt{@} {\it rate}
}

Token expressions follow the grammar in Table~\ref{tab:tokens}.
%%
\begin{table}[ht!]
  \centering
  \caption{Token expressions.}
  \begin{tabular}{@{} lcl @{}}
   \textit{token\_expression} &::=&  \textit{algebraic\_expression} \textit{token\_name} \\
	&&|  \textit{token\_expression} \tcb{,}\ \textit{token\_expression} \\\\
   \textit{token\_name} &::=& \tcb{Id}\\
  \end{tabular}
  \label{tab:tokens}
\end{table}

Using Kappa \imp{hybrid rules}, one may declare that an action has
effects on the concentration of some particles of the system. For
instance, a rule may consume atp, calcium ions, etc. It would be a waste
of memory and time to use discrete agents to represent such
particles. Instead one may declare tokens using
declarations\index{declaration} of the form:
\begin{lstlisting}[language=kappa]
%token: atp
%token: adp
\end{lstlisting}
One may then use these tokens in conjunction with a classical rule
using the hybrid format:
\begin{lstlisting}[language=kappa]
'hybrid rule' S(x{u}[1]),K(y[1]) | 0.2 atp -> S(x{p}[.]),K(y[.]) | 0.1 adp @ 'k'
\end{lstlisting}
When applied, the above rule will consume 0.2 \ttt{atp} token and
produce 0.1 \ttt{adp} token. Note that as specified by the grammar
given in Table~\ref{tab:tokens}, the number of consumed (and produced)
tokens can be given by a sum of the form: \ITE{
\item[] \ttt{\textit{lhs} | a$_1$ t$_1$, ..., a$_n$ t$_n$ $\rar$
  \textit{rhs} | a$_1'$ t$_1'$, ..., a$_k'$ t$_k'$ @ r} } where each
$a_i,a_i'$ is an arbitrary algebraic expression\index{algebraic
  expression} ({\eg}see Table~\ref{tab:alg}) and each $t_i,t_i'$ is a
declared token. In the above hybrid rule, denoting by  $n_i,n_i'$ the
respective evaluation of $a_i$ and $a_i'$, the concentration of token $t_i$ will
decrease from $n_i$ and the concentration of token $t_i'$ will
increase from $n_i'$.

Importantly, the activity\index{activity} of a hybrid rule is still
defined by \ttt{|\textit{lhs}|*r}, where \ttt{|\textit{lhs}|} is
the number of embeddings of the LHS of the rule in the mixture, and
\emph{does not take into account the concentration of the tokens it
  mentions}. It is however possible to make its rate explicitly
depend on the concentrations of the tokens using a \imp{variable}
rate.

Consuming $t$ tokens is strickly equivalent to producing $-t$
tokens. All variations in amount of tokens can be written on the RHS
of rules. This is what is done in edit notation when tokens
are used:
\begin{lstlisting}[language=kappa]
'hybrid rule' S(x~u/~p!1/),K(y!1/) | (-0.1) atp @ 'k'
\end{lstlisting}

The variations make clear that the simulator
does not check that the consumed amount of token is available. It
consumes tokens even if the quantity becomes then negative!

\section{Initial conditions}\label{sec:init}\index{initial condition}

The initial mixture\index{mixture} to which rules in the
KF\index{Kappa file} will be applied are declared as follows: \ITE{
\item[] \ttt{\%init: } \textit{algebraic\_expression} \textit{Kappa\_expression}
}
or:
\ITE{
\item[] \ttt{\%init: }  \textit{algebraic\_expression} \textit{token\_name}
}

%%
where \textit{algebraic\_expression} is evaluated before
initialization of the simulation (hence all token and Kappa expression
values in the expression are evaluated to 0). This will add to the
initial state of the model multiple copies of the graph described by
the Kappa expression. The DCDW convention\index{don't care don't
  write} allows us not to write the complete interface of added agents
(the remaining sites will be completed according to the agent's
signature\index{agent signature}). For instance:
\begin{lstlisting}[language=kappa]
%var: 'n' 1000
%init: 'n' A(),A(y{p})
%init: 0.39 ca2+ //mM
\end{lstlisting}
will add 1000 instances of \ttt{A} in its default state
\ttt{A(x[.],y\{u\}[.],z\{e0\}[.])}, 1000 instances of \ttt{A} in
state \ttt{A(x[.],y\{p\}[.],z\{e0\}[.])} and a concentration of 0.39
mM of calcium ions. Recall that the concentration of calcium can be
observed during simulation by using the expression \ttt{|ca2+|}.  As
any other declaration\index{declaration}, \ttt{\%init} can be used
multiple times, and agents will add up to the initial state.

\section{Intervention language}\label{sec:mod}
Getting something out of a model is done like in lab experiment
through intervention.

Each intervention directive is splitted in 4 parts:
\begin{description}
\item[clock] When trying to intervene should be considered
\item[condition] what is the condition under which the intervention is triggered
\item[intervention] what are the interventions
\item[repeatition] if the intervention is triggered, under what
  condition should it be still tried afterward
\end{description}

There are 3 categories of intervention:
\begin{description}
\item[modification] where the model is changed at the time of trigger
  (a special rule applied, a variable changed, the simulation stopped)
\item[immediate measurement] where a measure is taken at the time of
  trigger (value of \%plot printed, the current status of the mixture
  output, ...)
\item[continuous measurement switch] where you start or stop a
  measurement at time of trigger
\end{description}
They are all described in detail below.

\subsection{directive syntax}
The general syntax is
\ITE{
\item[] \ttt{\%mod:} \ttt{alarm} \textit{float} \textit{boolean\_expression} \ttt{do} \textit{effect\_list} \ttt{repeat} \textit{boolean\_expression}
}
for
\ITE{
\item[] \ttt{\%mod:} \textit{clock} \textit{condition} \ttt{do} \textit{intervention} \ttt{repeat} \textit{repeatition}
}

and syntactic sugar detailed below is provided.

\textit{Boolean\_expression} and \textit{effect\_list}\index{effect} are defined by the grammar given in Table~\ref{tab:pert} (the operator \ttt{rel} can be any usual binary relation in $\set{<,=,>}$ and algebraic expressions\index{algebraic expression} are defined in Table~\ref{tab:alg}).

\begin{table}[htbp]
  \centering
  \caption{Intervention expressions.}
  \begin{tabular}{@{} lcl @{}}
    \textit{boolean\_expression} &::=& \textit{algebraic\_expression}\index{boolean expression} \tcb{rel} \textit{algebraic\_expression} \\
    && | (\textit{boolean\_expression} \tcb{||} \textit{boolean\_expression}) \\
    && | (\textit{boolean\_expression} \tcb{\&\&} \textit{boolean\_expression}) \\
    && | \tcb{[not]} \textit{boolean\_expression} \\
    && | \tcb{[true]} | \tcb{[false]} \\\\
    \textit{effect\_list} &::=& \textit{effect} \tcb{\ttt {;}} \textit{effect\_list} | \textit{effect} \\\\
\textit{effect} &::=& \tcb{\$ADD} \textit{algebraic\_expression agent\_expression} \\
    && | \tcb{\$DEL} \textit{algebraic\_expression agent\_expression} \\
    && | \textit{token\_name} \tcb{<-} \textit{algebraic\_expression} \\
    && | \tcb{\$SNAPSHOT} \textit{string\_expression}\\
    && | \tcb{\$STOP} \textit{string\_expression}\\
	&& | \tcb{\$DIN} \textit{string\_expression} \textit{boolean} \\
    && | \tcb{\$TRACK \var{var\_name}} \textit{boolean} \\
    && | \tcb{\$UPDATE \var{var\_name}} \textit{algebraic\_expression} \\
    && | \tcb{\$PLOTENTRY} \\
    && | \tcb{\$PRINT} \textit{string\_expression} \tcb{<}\textit{string\_expression}\tcb{>} \\
    && | \tcb{\$SPECIES\_OFF} \textit{string\_expression} \textit{Kappa\_expression} \textit{boolean} \\
    \\
    \textit{string\_expression} &::=& \tcb{$\varepsilon$} | \tcb{"string" . } \textit{string\_expression} \\
    && | \textit{algebraic\_expression}\tcb{ . } \textit{string\_expression} \\\\
	\textit{boolean} &::=& \tcb{[true]} | \tcb{[false]}
  \end{tabular}
  \label{tab:pert}
\end{table}

There are 2 kind of clocks, an event based one and simulation time ones.

The event based one has the empty string for syntax: if nothing is
written for clock, it uses the event based clock. It fires at the
beginning of the simulation and every time a rule has just fired.

The time based one syntax is \ttt{alarm} \textit{float}, it fires
every amount of time unit given by the float (including at [T]=0).

For example
\lstinline[language=kappa]@%mod: alarm 2.3 [true] do $PLOTENTRY; repeat [true]@
will print a line in the data file every 2.3 time unit of
simulation whereas
\lstinline[language=kappa]@%mod: |A()| > 1000 do $PLOTENTRY; repeat |B(x[_])| < |B(x[.])|@
will do it every event where there is more than
1000 A up to the first event where (there is more than 1000 A) and
the number of \lstinline[language=kappa]@|B(x[_])|@ becomes bigger than the number of
\lstinline[language=kappa]@|B(x[.])|@.

When the conditions of several interventions that are tested at the
same moment are satisfied simultanously, interventions are triggered
in the order in which they have been declared in the KF\index{Kappa
  file}. A intervention can only be fired once per event loop.

\subsection{shortcuts}
If the repeat keyword and the repeat condition are ommited, it is assumed that it is
\lstinline[language=kappa]!repeat [false]! aka a one-shot intervention.

If the (pre)condition is ommited, it is considerated to be
\lstinline[language=kappa]![true]! unless both conditions are ommited
and a clock is provided. In this case the implicit condition is
\lstinline[language=kappa]![T] > 0! so that
\lstinline[language=kappa]!%mod: alarm 5.8 do effects!
is somehow a 'at' operator. It means ``do \texttt{effects} at [T] = 5.8''.

\subsection{Model modification}
\subsubsection{Applying a rule during a simulation}

\paragraph{Special cases: simply adding or deleting agents}

Continuing with the ABC model, the intervention effect\index{effect}:
\lstinline[language=kappa]*$ADD n C(x1~p)*
will add $n\geq 0$ instances of \ttt{C} with \ttt{x1} already in state \ttt{p} (and the rest of its interface in the default state as specified line 4 of ABC.ka). Also the intervention effect\index{effect}:
\lstinline[language=kappa]*$DEL |B(x!_)| B(x!_)*
will remove \emph{all} \ttt{B}s connected to some agent from the mixture\index{mixture}.

There are various ways one can use interventions to study more deeply a given Kappa model. A basic illustration is the use of a simple intervention to let a system equilibrate before starting a real simulation. For instance, as can be seen from the curve given in Fig.~\ref{fig:abc}, the number of AB complexes is arbitrarily set to 0 in the initial state (all \ttt{A}s are disconnected from \ttt{B}s in the initial mixture\index{mixture}). In order to avoid this, one can modify the Kappa file in the following way: one sets the initial concentration of \ttt{C} to 0 by deleting line 22. Now one introduces \ttt{C}s after 25 t.u using the intervention:
\lstinline[language=kappa]*%mod:  [T]=25 do $ADD 10000 C();*.

The modified Kappa file is available in the source repository, in the \ttt{model/} directory (file \ttt{abc-pert.ka}).
Run a simulation again (a bit longer) by entering in the command line:
\ttt{
\ITE{
\item[\$] KaSim ABC-pert.ka -l 300 -p 0.3 -o abc2.out
}}
one obtains the curve given in Fig.~\ref{fig:abc2}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=10cm]{generated_img/plot-abc2.pdf}
\caption{Simulation of the ABC model with a intervention: for t<25s, only \ttt{{\textquotesingle}a.b{\textquotesingle}} and \ttt{{\textquotesingle}a..b{\textquotesingle}} rules may apply. This enables the concentration of \ttt{{\textquotesingle}AB{\textquotesingle}} complexes to go to steady state, before introducing fresh \ttt{C}s at t=25s.}
\label{fig:abc2}
\end{center}
\end{figure}



\subsubsection{Updating kinetic rates on the fly}

Any variable between simple quotes can be updated during a simulation using a declaration\index{declaration} of the form:
\lstinline[language=kappa]!%mod: 'Cpp' > 500 do $UPDATE 'k_on' 0.0;!

This intervention will be applied whenever the observable \ttt{\var{Cpp}} will become greater than 500. Its effect will be to set the on rate of all binding rules to 0. Note that, according to the grammar given in Table~\ref{tab:pert}, one may use any algebraic expression\index{algebraic expression} as the new value of the variable. For instance:
\lstinline[language=kappa]!%mod: 'Cpp' > 500 do $UPDATE 'k_on' 'k_on'/100;!
\noi will cause the on rate of all rules to decrease a hundred fold. Note that, it is possible to override the kinetic rate of a specific rule:  in our ABC example, the declaration\index{declaration}:
\lstinline[language=kappa]!%mod: 'Cpp' > 500 do $UPDATE 'a.b' inf;!
\noi will set the kinetic rate of rule \ttt{\var{a.b}}~to infinity.

\subsubsection{Interrupt simulation}
The intervention \ttt{\$STOP} will interrupt the simulation. It
returns the hand to the user if one run in interactive mode or
terminates the run in batch mode.

The intervention \ttt{\$STOP "final\_state.ka"} will in addition
produce a snapshot of the last mixture\index{mixture}.

\subsection{Model immediate examination}
Advanced and/or experimental examinations are listed in chapter \ref{chap:advanced}.

\subsubsection{Get a snapshot of the mixture}

A snapshot is an instant photography of the current state of the
mixture (a dump of the state at a given moment in the simulation).

A snapshot is suitable as an initial condition for a model.
In the previous example, we let the system evolve for some time
without its main reactant \ttt{C} in order to let other reactants go
to a less arbitrary initial state. One may object that this way of
proceeding is CPU-time consuming if one has to do this at each
simulation.

An alternative is to use the \ttt{\$SNAPSHOT} primitive
that allows a user to export a snapshot of the mixture\index{mixture}
at a given time point as a new (piece of) Kappa file.  For instance,
the declaration\index{declaration}:
\lstinline[language=kappa]*%mod: [E-]/([E]+[E-])>0.9 do $SNAPSHOT "prefix";*
will ask \KaSim~to export
the mixture\index{mixture} the first time the percentage of null
events reaches 90\%. The exported file will be named
\ttt{prefix\_$n$.ka} where $n$ is the event number at which the
snapshot was taken. One may also use a \textit{string\_expression} to
construct any prefix using local variables.

One may omit to define a prefix and simply type:
\lstinline[language=kappa]!%mod: [E-]/([E]+[E-])>0.9 do $SNAPSHOT;!
in which case the default prefix \ttt{snap.ka} will be used for naming snapshots.

If the name already exists, a counter will be appended at the end of
the file to prevent overwriting. Snapshots can be performed multiple
times, for instance every 1,000 events, using the
declaration\index{declaration}:
\begin{lstlisting}[language=kappa]
%mod: ([E] [mod] 1000)=0 do $SNAPSHOT "abc.ka"; repeat [true]
\end{lstlisting}
which results in \KaSim~producing a snapshot every 1000 (productive) events until the simulation ends.

Note that instead of producing Kappa files, one may use snapshot
interventions to produce an image of the mixture\index{mixture} in the
dot/html format using the parameter by specifying the extention in the
name skeleton
(\lstinline[language=kappa]!%mod: [E-]/([E]+[E-])>0.9 do $SNAPSHOT "snap.dot";!).

\subsubsection{Printing values during a simulation}
The effect \ttt{\$PRINT \textit{string\_expression}
   >\textit{string\_expression}} enables one to output values during a
computation to:
\begin{itemize}
\item standard output if the second \textit{string\_expression} and
  the \ttt{>} are ommited,
\item to the file specified by the second \textit{string\_expression} otherwise.
\end{itemize}
For instance:
\begin{lstlisting}[language=kappa]
%mod: |A|<0 do
    $PRINT ("Token A is: " . |A| . " at time=". [T]) > ("token_".[E].".dat");
    repeat [true]
\end{lstlisting}

will ask \KaSim~to output the value of token \ttt{A} in a file
"token\_$n$.dat" which changes at each new productive event, each time
its value gets below 0.

\subsubsection{Add an entry in the output data}
The effect \ttt{\$PLOTENTRY} outputs a line with the current value of observables in the data file. For example,
\lstinline[language=kappa]!%mod: repeat [E] [mod] 10 = 0 do $PLOTENTRY; until [false]!
will store the value of observables every 10 productive events.

\chapter{The \Kappa{} tools}
\section{The \KaSim~engine}
\KaSim~is a stochastic simulator of rule-based
models~\cite{DanLan04,Dan_etal07a,Fae_etal05} written in
\Kappa. \KaSim~takes one or several \hyperref[chap:kappa]{Kappa files}
as input and generates stochastic trajectories of various
observables. \KaSim~implements Danos \textit{et al}'s implicit state
simulation algorithm~\cite{Dan_etal07b} which adapts Gillespie's
algorithm~\cite{Gil76,Gil77} to rule-based models.

A \emph{simulation event}\index{event} corresponds to the application
of a rewriting rule, contained in the Kappa files, to the current
graph\index{graph} (also called a \emph{mixture}\index{mixture}).
%The rule is selected according to its
%\emph{activity}\index{activity}, \ie the number of instances it has
%in the current mixture\index{mixture}, multiplied by its kinetic
%rate\index{kinetic rate}
At each step, the next event is selected with a probability which is
proportional to the rate\index{rate} of the rule it is an event of.
%It is then applied to one of its possible instances in the graph.
%The result of triggering this event is a new graph.
If there are no events, {\ie}if none of the rules apply to the current
state of the system, one has a \emph{deadlock}. Note that a given rule
will in general apply in many different ways; one says it has many
instances. The \emph{activity}\index{activity} of a rule is the number
of its instances in the current mixture\index{mixture} multiplied by
its rate. The probability that the next event is associated to a given
rule is therefore proportional to the activity of the rule.  Rule
activities\index{activity} are updated at each step (see
Fig.~\ref{fig:event-loop}). Importantly, the cost of a simulation
event is bounded by a constant that is independent of the size of the
graph it is applied to~\cite{Dan_etal07b}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=14cm]{img/event-loop.png}
\caption{The event loop.}
\label{fig:event-loop}
\end{center}
\end{figure}

\section{The \KaSa~static analyser}

\KaSa~is a static analyser tool of rule-based
models~\cite{DanLan04,Dan_etal07a,Fae_etal05} written in
Kappa. \KaSa~takes one or several \hyperref[chap:kappa]{Kappa files}
as input and some command line options to toggle on/off some specific
static analysis. Currently, \KaSa~can compute \imp{the contact map}
and \imp{the influence map}. It can perform reachability analysis
\cite{Feret-ICCMSE2007,DanosEtAl-VMCAI08} as well.

A graphical interface is proposed to navigate through the various
options and utilities of \KaSa. The compilation of this interface
requires \href{https://forge.ocamlcore.org/projects/labltk/}{labltk}
and, in particular, \href{http://www.tcl.tk/}{tk-dev}.

\section{The \KaDE~ODEs generator}

\KaDE~is a tool to compile rule-based
models~\cite{DanLan04,Dan_etal07a,Fae_etal05} written in Kappa into
systems of ordinary differential equations, or equivalently into
reaction networks. It also supports some model reduction techniques,
that may reduce the dimension of the ODEs (or the number of different
bio-molecular species in reaction networks).

\KaDE~takes one or several \hyperref[chap:kappa]{Kappa files} and uses
some command line options in order to select a backend format, tune
the semantics, and call some model reduction methods.

A graphical interface is proposed to navigate through the various
options and utilities of \KaDE. The compilation of this interface
requires \href{https://forge.ocamlcore.org/projects/labltk/}{labltk}
and, in particular, \href{http://www.tcl.tk/}{tk-dev}.

\chapter{The stochastic simulator: \KaSim}\label{chap:cl}

\section{General usage}
From a terminal window, \KaSim~can be invoked by typing:
\ITE{
\item[\$] \ttt{KaSim file\_1 ... file\_n [option] } } where
\ttt{file\_i} are the input Kappa files containing the rules, initial
conditions and observables ({\eg}see Chapter~\ref{chap:kappa}). A
simulation can generate several files that are described in the present chapter. One
should really take advantage of the option \ttt{-d} so that these files  all
ends in a distinct directory.

In any case, a log called \ttt{inputs.ka} is generated. This is a
valid Kappa file such that \ttt{KaSim inputs.ka} reruns exactly the
simulation just ran outputing the exact same outputs (using the same
pseudo random numbers!). First line of this file contains an \ttt{uuid}
that is also present in any file output during the same run.

Tables~\ref{tab:options} and \ref{tab:add-options} summarize all the
options that can be given to the simulator.

Basically, one can specify an upper bound and a plot period either in
simulated or bio-time (arbitrary time unit), or in number of events.
Note that bio-time is computed using
Gillespie{\textquotesingle}s formula for time advance (see
Fig.~\ref{fig:event-loop}) and should not be confused with CPU-time
(it is not even proportional).
%In doubt, we recommend using a bound in number of events since the
%cost of one event is bounded (in CPU time) by a constant, so the
%CPU-time used for simulating $n$ events is roughly $k$ times lower
%than that used for simulating $k\times n$ events.

\section{Main options}

Table~\ref{tab:options} summarizes the main options that are
accessible through the command line. Options that expect an argument
are preceded by a single dash, options that do not need any argument
start with a double dash.

Two key options are the plot period \ttt{-p} (how often you want a
line in the data file) and the limit \ttt{-l} of simulation. These
quantities can expressed in simulated time (the default) or in number
of event (using \ttt{-u event}).

\begin{table}[h!]
\caption{Command line: main options.}
\centering
\begin{tabular}{|l|l|}
\hline
Argument & Description \\ \hline
\ttt{-u $unit$} & Unit of options (time/event)\\
\ttt{-l $max$} & Terminates simulation after $max \geq 0$ $unit$\\
\ttt{-initial $min$} & Starts the simulation at $min$ $unit$ (data outputs convienience only)\\
\ttt{-p $x$} & Plot a line in the data file every $x$ $unit$\\
\ttt{-o} \textit{file} & Set the name of data file to \textit{file}\\
&Use the extension to determine format ('.tsv', '.svg' or csv else)\\
\ttt{-i} \textit{file} & Interpret \textit{file} as an input file name\\
& (for compatibility with \KaSim <= 3 and file names starting by -)\\
\ttt{-d} \textit{dir} & Output any produced file to the directory \textit{dir}\\
\hline
\end{tabular}
\label{tab:options}
\end{table}%

\section{Advanced options}

Table~\ref{tab:add-options} summarizes the advanced options that are accessible through the command line.

\begin{table}[h!]
\caption{Command line: advanced options.}
\centering
\begin{tabular}{|l|l|}
\hline
Argument & Description \\ \hline
\ttt{ -rescale $r$} & Multiply each initial quantity by $r$ \\
\ttt{ \dd no-log} & Do not generate a reproductability file \\
\ttt{ -log \textit{file}} & Specify the name of the reproductability file \\
& (default ``inputs'') \\
\ttt{ -seed $n$} & Seeds the pseudo-random number generator $n>0$ \\
\ttt{ -make-sim} \textit{sim\_file} & Makes a simulation package out of the input KF\index{Kappa file} \\
\ttt{ -load-sim} \textit{sim\_file} & Use simulation package \textit{sim\_file} as input\\
\ttt{ \dd gluttony} & Simulation mode that is memory intensive \\ & but that speeds up simulation time\\
\ttt{ -mode batch} & Set non interactive mode (never halt waiting for an user\\
& action but assume default (data loosing) answer)\\
\ttt{ -mode interactive} & Launch the toplevel just after model initialisation\\
\hline
\end{tabular}
\label{tab:add-options}
\end{table}%
%

\section{Example}
The command:
\ITE{
\item[\$] \ttt{KaSim model.ka -u event -l 1000000 -p 1000 -o model.out}
}
will generate a file \ttt{model.out} containing the trajectories of the observables defined in the Kappa file \ttt{model.ka}. A measure will be taken every 1000 events in file \ttt{model.out}. The command:
\ITE{
\item[\$] \ttt{KaSim init.ka rules.ka obs.ka mod.ka -l 1.5 -p 0.0015}
}
will generate a file \ttt{data.csv} (default name) containing 1,000 data points of a simulation of 1.5 (arbitrary) time units of the model. The input Kappa file is split into four files containing, for instance, the initial conditions, \ttt{init.ka}, the rule set, \ttt{rules.ka}, the observables, \ttt{obs.ka}, and the interventions, \ttt{pert.ka} ({\eg}see Chapter~\ref{chap:kappa}). %The order in which the files are given does not matter.

\section{Interactivity}
Simulations are interruptible by sending a \verb:SIGINT: to the
simulator. (The easiest way to send a \verb:SIGINT: to a process is to
press Ctrl-c in the terminal window it runs into.)

In batch mode, this stops the simulation. In other circumstances, it
launches a toplevel in which one can either type:
\begin{itemize}
\item \verb:$RUN: (optionally followed by a pause condition) to resume
  simulation or
\item any of the \emph{effects} described in Section \ref{sec:mod} to trigger it imediately.
\end{itemize}

A pause condition is a boolean expression ({\eg}Section \ref{sec:mod}) under which the simulator will stop and fall back in
the toplevel in order to allow a new interactive session.

The option \ttt{-mode interactive} interrupts automatically the
simulation (and launches the toplevel) just after the initialization
of the simulation.

\chapter{Advanced concepts}\label{chap:advanced}

\section{Experimental continuous examination}
\subsection{Causality analysis}\label{sec:cflows}

In our ABC example, adding the instruction:
\lstinline[language=kappa]!%mod:  [true] do $TRACK 'Cpp' [true];!
\noi will ask~\KaSim~to turn on causality analysis\index{causality} for the observable \ttt{{\textquotesingle}Cpp{\textquotesingle}} since the beginning of the simulation, and display the causal explanation of every new occurrence of \ttt{{\textquotesingle}Cpp{\textquotesingle}}, until the end of the simulation. The explanation, that we call a \emph{causal flow}\index{causal flow}, is a set of rule applications ordered by causality and displayed as a graph using dot format. In this graph, an edge \ttt{r}$\longrightarrow$ \ttt{r{\textquotesingle}} between two rule applications \ttt{r} and \ttt{r{\textquotesingle}} indicates that the first rule application has used, in the simulation, some sites that were modified by the application of the former. We show in Fig.~\ref{fig:cflow} an example of such causal flow.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=5cm]{generated_img/cflow.png}
\caption{Causal flow for the observable \ttt{{\textquotesingle}Cpp{\textquotesingle}} of the ABC model. Plain arrows represent causal dependency, dotted arrows show asymmetric conflicts between rule occurrences. Here the \ttt{{\textquotesingle}ab.c{\textquotesingle}} rule has to occur before the \ttt{{\textquotesingle}a.b{\textquotesingle}} rule. The red observable indicates that the last rule allowed one to observe a new instance of \ttt{{\textquotesingle}Cpp{\textquotesingle}}.}
\label{fig:cflow}
\end{center}
\end{figure}

Causality analysis of the observable \ttt{Cpp} can be turned off at any time by using a declaration\index{declaration} of the form:
\lstinline[language=kappa]!%mod:  [T]>25 do $TRACK 'Cpp' [false];!

Each time \KaSim~detects a new occurrence of the observable that is being tracked, it will dump its causal past as a graph using the dot format (see Fig.~\ref{fig:cflow} above). The name of the file in which the causal flow is stored can be set by using the \texttt{\%def} instruction (see Section~\ref{sec:param}).

\subsubsection*{Compressing causal flows.}

In general, pure causal flows\index{causal flow} will contain a lot of information that modelers may not wish to consider. Indeed in classical flows, causality (represented by an edge between to rule applications in the graph) is purely local. Therefore a sequence $a\rar b \rar c$ only implies that an instance of rule $a$ caused an instance of rule $b$ which in turn created an instance of the observable $c$. However, it does not imply that $a$ was "necessary" for $c$ to occur (for instance, $c$ might have been possible before $a$ but not after, and $b$ would be simply re-enabling $c$). It is possible to tell \KaSim~to retain only events that are more strongly related to the observable using two compression techniques (see Ref.~\cite{Dan_etal12} for formal details). Intuitively, in a \emph{weakly} compressed causal\index{weak compression} flow one has the additional property that if an event $e$ is a (possibly indirect) cause of the observable, then preventing $e$ from occurring would have prevented the rest of the causal flow to occur ({\ie}it is not possible to reconstruct a computation trace containing the observable with the events that remain in the causal flow). A \emph{strongly} compressed causal flow enjoys the same property with an additional level of compression obtained by considering different instances of the same rule to be indistinguishable\index{strong compression}. Note that, causal flow compressions may be memory and computation demanding. For large systems it may be safer to start with weak compressions only.

The type of compression can be set using the \texttt{\%def} instruction (see Section~\ref{sec:param}). For instance:
\lstinline[language=kappa]!%def: "displayCompression" "none" "weak" "strong"!
will ask \KaSim~to output 3 versions of each computed causal flow, with all possible degrees of compressions. Each causal flow is outputted into a file \texttt{[filename][Type]\_$n$.dot} where \texttt{filename} is the default name for causal flows which can be redefined using the parameter \texttt{cflowFileName}, \texttt{Type} is the type of compression (either nothing or \texttt{Strongly}, or \texttt{Weakly}) and $n$ is the identifier of the causal flow. For each compression type a summary file, named \texttt{[filename][Type]Summary.dat}, is also produced. It allows to map each compressed causal flow to the identifier of its uncompressed version (row \texttt{\#id}), together with the production time $T$ and event number $E$ at which the observable was produced. It also contains information about the size of the causal flow.

\subsubsection{Limit the number of flows}
As an example, consider the computation of causal flows between $t=10$ and $t=20$ using the declarations:
\begin{lstlisting}[language=kappa]
%mod: [T]>10 do $TRACK 'Cpp' [true];
%mod: [T]>20 do $TRACK 'Cpp' [false];
\end{lstlisting}

The above declaration will ask \KaSim~to analyze each new occurrence of \ttt{\var{Cpp}} in that time interval. If $n$ new instances took place, then \KaSim~will have to compute $n$ causal flows. One may want to bound the number of computed flows to a certain value, say 10. One may do so using the combination of interventions and variables given below:
\begin{lstlisting}[language=kappa]
%var: 'x' 0
%mod: [T]>10 do ($TRACK 'Cpp' [true] ; $UPDATE 'x' 'Cpp')
%mod: [T]>20 || ('x' > 0 && 'Cpp' - 'x' > 9) do $TRACK 'Cpp' [false];
\end{lstlisting}
The first line is a declaration of an $x$ variable that is initially set to 0. Note that, the second line is a intervention that contains two simultaneous effects, the first one triggering causality analysis and the second one updating the value of variable $x$ to the current value of variable \ttt{\var{Cpp}}.
The last line stops causality analysis whenever time is greater than 20 or when 10 new observables have been found (the difference between the current value of \ttt{\var{Cpp}} and $x$).


\subsection{Dynamic influence network}\label{sec:flux}

\begin{figure}[p] %  figure placement: here, top, bottom, or page
   \centering
\includegraphics[width=15cm]{generated_img/flux.png}
   \caption{Dynamic influence network of the \ttt{abc.ka} model, taken
     from t=0 to t=20 time units. The \ttt{A} releasing rules
     \ttt{a..b} and \ttt{mod x2} are contributing very little to the
     activity of \ttt{a.c} which is a sign of an excess of free
     \ttt{A}s in the system at this time interval.}
   \label{fig:flux}
\end{figure}
%%
The \emph{dynamic influence network (DIN)}\index{dynamic influence network}\index{DIN}
is a powerful observation that tracks, on the fly, the influence that
rule applications have on each others. It is dynamically generated and
tracks effective impacts (positive or negative) at every rule
application. The DIN can be computed using
declaration\index{declaration}s of the form:
\begin{lstlisting}[language=kappa]
%mod: [true] do $DIN "flux.dot" [true];
%mod: [T]>20 do $DIN "flux.dot" [false];
\end{lstlisting}
The result is a graph where a positive edge between
rules $r$ and $s$ (in green) indicates an overall positive
contribution of $r$ over $s$. Otherwise, the sum of $r$ applications
increased the activity\index{activity} of $s$. Conversely, a negative
edge (in red) will indicate that $r$ had an overall negative impact on
the activity\index{activity} of $s$. Note that, the importance of the
influence between two rules can be observed by looking at the label on the
edges that indicate the overall activity transfer (positive or
negative) between the rules. The above declaration\index{declaration}
produces the network shown in Fig.~\ref{fig:flux}. Note that,
influence may vary during time, therefore the time or event limit of the
simulation is of importance and will likely change the aspect of the
produced map.

\subsection{Print species of an observable}
The effect \ttt{\$SPECIES\_OFF} tracks the occurrence of an observable. Each time a new instance of the observable appears, the \emph{species} in which it occured is printed in a file. For example:
{\begin{lstlisting}[language=kappa]
%mod:$SPECIES_OF "species.ka" A(a!1), B(a!1) [true];
\end{lstlisting}}
prints in the file \ttt{"species.ka"} a new line for each new occurrence of \ttt{A(a!1), B(a!1)} with the time of occurrence and the species in which it occurred.

Note that, this intervention can only be applied if the observable is a connected component.

\section{Implicit signature}
\KaSim~permits users in a hurry to avoid writing agent signatures explicitly using the option \ttt{-\,-implicit-signature} of the command line. The signature is then deduced using information gathered in the KF\index{Kappa file}. Note that, it is not recommended to use the DCDW convention for introduced agents in conjunction with the \ttt{-\,-implicit-signature} option unless the default state of all sites is mentioned in the \ttt{\%init} declaration\index{declaration}s or in the rules that create agents.

\section{Simulation packages}

The simulation algorithm that is implemented in \KaSim~requires an initialization phase whose complexity is proportional to $R*G$ where $R$ is the cardinal of the rule set and $G$ is the size of the initial mixture\index{mixture}. Thus for large systems, initialization may take a while. Whenever a user wishes to run several simulations of the \emph{same} Kappa model, it is possible to skip this initialization phase by creating a \emph{simulation package}\index{simulation package}. For instance:
\ttt{\ITE{
\item [] KaSim abc.ka -l $n$ -make-sim abc.kasim
}}
will generate a standard simulation of the \ttt{abc.ka} model, but in addition, will create the simulation package \ttt{abc.kasim} (\ttt{.kasim} extension is not mandatory). This package is a binary file, {\ie}not human readable, that can be used as input of a new simulation using the command:
\ttt{\ITE{
\item [] KaSim -load-sim abc.kasim -l $k$
}}
Note that this simulation is now run for $k$ time units instead of $n$. Importantly, simulation packages can only be given as input to the \emph{same} \KaSim~that produced it. As a consequence, recompiling the code, or obtaining different binaries, will cause the simulation package to become useless.

\section{Simulation parameters configuration}\label{sec:param}

In the KF\index{Kappa file} (usually in a dedicated file) one may use expressions of the form:

\hfill\hbox{\ttt{\%def: "}\textit{parameter\_name}\ttt{" "}\textit{parameter\_value}\ttt{"}}\hfill\null

where tunable parameters are described in table~\ref{tab:parameters} (default values are given first in the possible values column).
%%
\begin{table}[ht]
\caption{User defined parameters.}
\begin{tabular}{l|l|l}
parameter & possible values & description \\
\hline
\textit{Simulation} & &\\
\ttt{"maxConsecutiveClash"} & \ttt{"2"} or any integer & \small number of consecutive clashes \\
&& \small before giving up \\
&& \small square approximation\\
\ttt{"T0"} & float & \small simulation starting time\\
&& \small (outputs convienience only)\\
\ttt{"seed"} & any positive integer & \small pseudo-random number\\
&& \small generator seed\\ \hline
\textit{Outputs}&&\\
\ttt{"traceFileName"} & string & \small outputs simulation trace\\
&&\small in the given file\\
\ttt{"outputFileName"} & string & \small data file name\\
\ttt{"plotPeriod"} & number then optionally& \small interval between\\
& \ttt{"events"} & plot lines\\
\textit{Causality analysis}&\textbf{deprecated}&\textbf{please use KaStor}\\
\ttt{"displayCompression"} & any combination of & \small type of compression \\
&  \ttt{"none", "strong", "weak"} & \\
\ttt{"cflowFileName"} & \ttt{"cflow"}, any string & \small file name prefix for causal flows\\
\ttt{"dotCflows"} & \ttt{"no", "html"} & \small generate causal flows in html \\
& \ttt{"yes", "dot"} & \small generate causal flows in dot \\
& \ttt{"json"} & \small generate causal flows in json\\ \hline
\textit{Pretty printing}& &\\
\ttt{"dumpIfDeadlocked"} & \ttt{"no","yes"} & \small snapshot when simulation \\&&\small is stalled\\
\ttt{"colorDot"} &  \ttt{"no", "yes"} & \small use colors in dot format files\\
\ttt{"progressBarSymbol"} & \ttt{"\#"} or any character & \small symbol for the progress bar\\
\ttt{"progressBarSize"} & \ttt{"60"} or any integer & \small length of the progress bar\\
\end{tabular}
\label{tab:parameters}
\end{table}
%%

\section{Counters}

An agent can have \emph{counters}, which are sites storing a positive integer. When declaring an agent, each counter has to be assigned a \emph{min} and a \emph{max} value.
For instance, the agent \ttt{\%agent: A(x,c:1 += 4,d:0 +=2)} has two counters, named $c$ and $d$, which range from $1$ to $4$, and from $0$ to $2$, respectively.

%%
\begin{table}[htbp]
  \centering
  \caption{Agent signature with counters extends in Table~\ref{tab:sig}}
  \begin{tabular}{@{} lcl @{}}
    \textit{signature\_expression} & ::= &
    \tcb{Id}\tcb{(}\textit{sig}\tcb{)} \\

    \textit{sig} & ::= &
    \tcb{Id}~\textit{internal\_state\_list}\tcb{,}\ \textit{sig} $\mid$ \tcb{Id}~\textit{counter\_test}~\textit{counter\_modif}\tcb{,}\ \textit{sig}
    $\mid\varepsilon$ \\
 \end{tabular}
\end{table}
%%

At initialisation, an initial value for the counter has to be specified.

In rules, all counter tests have to be in the LHS, while the counter modifications in the RHS.
A counter test can do three things: (i) check that the counter value is equal to a positive integer; (ii) check that the counter's value is greater than a positive integer or (iii) declare a variable, to which the counter's value is assigned. The variable can then be used in the rate constant.

A counter modification increments or decrements the original counter value. In the following table, $n\leq 0$ and both $n$ and $i$ are integers.
\begin{table}[ht!]
  \centering
  \caption{Counter expressions}
  \begin{tabular}{@{} lcl @{}}
    \textit{counter\_expression} & ::= & \tcb{Id}~\textit{counter\_test}~\textit{counter\_modif}$\mid\varepsilon$ \\
    \textit{counter\_test} & ::= & \tcb{: n} $\mid$ \tcb{:> n} $\mid$ \tcb{:> variable} $\mid\varepsilon$\\
    \textit{counter\_modif} & ::= & \tcb{: i} $\mid\varepsilon$\\
    \end{tabular}
\end{table}

If the counter goes negative, the compilation stops with an error. If the counter goes up beyond its declared maximum value, the simulation stops with an error.

\chapter{The \KaSa~static analyser}

\section{General usage}

From a terminal window, \KaSa~can be invoked by typing the following command line:
\ITE{
\item[\$] \ttt{KaSa file\_1 ... file\_n  [option]}
}
where \ttt{file\_i} are the input Kappa files containing the rules, initial conditions and observables (see Chapter~\ref{chap:kappa}).

All the options are summarised as follows:
\input{generated_img/KaSa_options.txt}

Order in options matters, since they can be used to toggle on/off some functionalities or to assign a value to some environment variables.
The options are interpreted from left to right.

More options are available in the OCaml file \texttt{KaSa\_rep/config/config.ml} and can be tuned before compilation.

\section{Graphical interface}

\subsection{Launching the interface}

The graphical interface can be launched by typing the following command line:
\ITE{\item[\$] \ttt{KaSa}}

without any option.

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kasa_0.png}
\caption{\KaSa~ graphical interface - sub-tab \texttt{Actions}.}
\label{fig:kasa:0}
\end{figure}

\subsection{The areas of interest}

There are five different areas of importance in the graphical interface:
\begin{enumerate}
\item On the top left of the window, a button allows for the selection between the Normal and the Expert mode (other modes may be available if activated at compilation).
In expert mode, more options are available in the graphical interface.
\item On the top center/right, some button allows for the selection of the tab. There are currently six sub-tabs available: \texttt{Actions}, \texttt{Syntax}, \texttt{Output}, \texttt{Reachability analysis}, \texttt{Trace analysis}, \texttt{Contact map}, \texttt{Influence map}.

\item In the center, the options of the selected sub-tab are displayed and can be tuned.

Contextual help is provided when the mouse is hovered over an element.

The interface will store the options that are checked or filled and the order in which they have been selected.
When launched, the analysis interprets these options in the order they have been entered.

Some options appear in several sub-tabs. They denote the same option and share the same value.

\item File selector: The file selector can be used to upload as many Kappa files as desired. The button '\texttt{Clear}' can be used to reset the selection of files.
\item Bottom: Some buttons are available. The button '\texttt{Quit}' can be used to leave the interface. The button '\texttt{Reset to default}' tunes all the options to their default value. The button '\texttt{Import options}' can be used to restore the value of the options as saved during a previous session of the graphical interfaces. The button '\texttt{Save options}' can be used to save the value of the options for a further session. The button '\texttt{Launch analyze}' launches \KaSa\ with the current options.

Importantly, options are saved automatically under various occasions. Thus, it is possible to restore the value of the options
before the last reset, before the last quit, or before the last analysis.
\end{enumerate}

\subsection{The sub-tab \texttt{Actions}}

The sub-tab \texttt{Actions} (see Fig.~\ref{fig:kasa:0}) contains the main actions which can be performed.

The following options are available:
\begin{itemize}
\item The button \texttt{-{}-do-all} activates all the functionalities.
\item The button \texttt{-{}-reset-all} inactivates all the functionalities.
\item The option \texttt{-{}-compute-contact-map} can be used to (des)activate the computation of the contact map.
\item The option \texttt{-{}-compute-influence-map} can be used to (des)activate the computation of the influence map.
\item The option \texttt{-{}-compute-potential-cycles} can be used to (des)activate the computation of the potential polymers.
\item The option \texttt{-{}-compute-reachability-analysis} can be used to (des)activate the computation of the reachability analysis.
\item The option \texttt{-{}-compute-symmetries} can be used to (des)activate the computation of pairs of equivalent sites. Equivalent sites may be used to reduce the number of variables in the system of ordinary differential equations that is associated to a Kappa model (e.g.~see Sect.~\ref{sec:kade:ex}).
\item The option \texttt{-{}-compute-local-traces} can be used to (des)activate the computation of the trace analysis.
\item The option \texttt{-{}-compute-separating-transitions} can be used to (des)activate the computation of the transitions that are non weakly
reversible. These are the transitions between two configurations of an agent, that are impossible to revert (even in several computation steps).
\end{itemize}

Lastly, a switch allows to select the version for Kappa syntax for the input file, among version $3$, \texttt{V3}, and version $4$, \texttt{V4}.

\subsection{The sub-tab \texttt{Syntax}}

\begin{figure}[htbp]
  \centering
\includegraphics[width=12cm,bb=0 0 1904 1208]{img/kasa_1.png}
\caption{\KaSa~ graphical interface - sub-tab \texttt{Syntax}.}
\label{fig:kasa:01}
\end{figure}

The sub-tab \texttt{Syntax} (see Fig.~\ref{fig:kasa:01}) contains the switch to select between the version 3, \texttt{V3}, and the version 4, \texttt{V4}, of Kappa syntax.

\subsection{The sub-tab \texttt{Output}}

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kasa_2.png}
\caption{\KaSa~ graphical interface - sub-tab \texttt{output}.}
\label{fig:kasa:1}
\end{figure}


The sub-tab \texttt{Ouput} (see Fig.~\ref{fig:kasa:1}) contains the names of the output files and their format.

The following options are available:
\begin{itemize}
\item The field \texttt{-{}-output-directory} can be used to set the repository where output file are written. \KaSa~will create this repository, if it does not exist.
\item The field \texttt{-{}-output-contact-map-directory} can be used to set the repository where the output file for the contact map is written, if a contact map is requested. \KaSa~will create this repository, if it does not exist.
\item The field \texttt{-{}-output-contact-map} contains the name of the file for the contact map. If the file name does not end by it, the proper extension will be added to the file name.
\item The field \texttt{-{}-output-influence-map-directory} can be used to set the repository where the output file for the influence map is written, if an influence map is requested. \KaSa~will create this repository, if it does not exist.
\item The field \texttt{-{}-output-influence-map} contains the name of the file for the influence map. If the file name does not end by it, the proper extension will be added to the file name.
\item The format for the influence map can be chosen among \texttt{DOT}, \texttt{DIM}, and \texttt{HTML} thanks to the option \texttt{-{}-influence-map-format}. In format \texttt{DIM}, the output of the influence map is a json file containing the support of the dynamic influence map that has been introduced in Sect.~\ref{sec:flux}.
\item The field \texttt{-{}-output-local-traces-directory} can be used to set the repository where the output file for the result of trace analysis is written, if this analysis is requested. \KaSa~will create this repository, if it does not exist.
\item The format for the local traces can be chosen among \texttt{DOT} and \texttt{HTML} thanks to the option \texttt{-{}-local-traces-format}.


\end{itemize}

When a file already exists, it is overwritten without any warning.

\section{Reachability analysis}

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kasa_3.png}
\caption{\KaSa~ graphical interface - sub-tab \texttt{Reachability\_analysis}.}
\label{fig:kasa:2}
\end{figure}

Reachability analysis aimed at detecting statically properties about the bio-molecular species that may be formed in a model.
Knowing whether, or not, a given bio-molecular species may be formed in a model is an undecidable problem \cite{Kreyssig}. Thus, our analysis is approximate. Indeed, it computes an over-approximation of the set of the bio-molecular species that can be reached from the initial state of the model, by applying an unbounded number of computation steps. As formalized in \cite{DanosEtAl-VMCAI08,Feret:SASB2016}, the abstraction consists in:
\begin{enumerate}
\item firstly, ignoring the number of occurrences of bio-molecular species (we assume that whenever a bio-molecular species may be formed, then it may be formed as many time as it could be necessary),
\item secondly, abstracting a bio-molecular species by the set of its properties.
\end{enumerate}
The analysis takes into account also the chemical species that may be introduced in a intervention.

The classes of properties of interest are encoded in so called abstract domains, which can be independently enabled/disabled. The whole analysis can be understood as a mutual recursion between smaller analyses (one per abstract domain), that communicate information between each other at each step of the analysis. We took the same scheme of collaboration between abstract domains as in  \cite{CousotEtAl06-ASIAN}.
% local views (that is to say that we focus on the relationships between the states of the sites within agents, but we abstract away any relationships between different agents within a bio-molecular species).
%\end{enumerate}

As an example, we consider the following model:
\begin{lstlisting}[language=kappa]
%agent: E(x)
%agent: R(x,c,cr,n)

%init: 1 E()
%init: 1 R()

'E.R' E(x[.]),R(x[.]) -> E(x[1]),R(x[1]) @1
'E/R' E(x[1]),R(x[1],c[.]) -> E(x[.]),R(x[.],c[.]) @1
'R.R' R(x[_],c[.]),R(x[_],c[.]) -> R(x[_],c[1]),R(x[_],c[1]) @1
'R/R' R(c[1],cr[.],n[.]),R(c[1],cr[.],n[.]) -> R(c[.],cr[.],n[.]),R(c[.],cr[.],n[.]) @1
'R.int' R(c[1],cr[.],n[.]),R(c[1],cr[.],n[.]) -> R(c[1],cr[2],n[.]),R(c[1],cr[.],n[2]) @1
'R/int' R(cr[1]),R(n[1]) -> R(cr[.]),R(n[.]) @1
'obs' R(x[.],c[.],cr[_],n[_]) -> R(x[.],c[.],cr[.],n[.]) @1
\end{lstlisting}

Typing the following command line:
\begin{verbatim}
KaSa reachability.ka --reset-all --compute-reachability-analysis
\end{verbatim}

will perform the reachability analysis on the model \texttt{reachability.ka}.

We obtain the following result:

\input{generated_img/LOG_low.txt}


This result is displayed in the standard output, and it is made of six parts.

The first two parts provide an enumeration of dead rules and dead agents.
The next parts display what we call refinement lemmas.
A refinement lemma is made of a precondition (on the left of the implication symbol) that is a site graph, and a postcondition (on the right of the implication symbol) that is a list of site graphs. Each site graph in the post-condition is a refinement of the precondition (the position of agent matters: the $n$-th agent in the precondition corresponds to the $n$-th agent in each site graph in the postcondition, but site graphs in a postcondition may have more agents than the site graph in the corresponding precondition).
The meaning of a refinement lemma is that every embedding between its precondition into a reachable state can be refined/extended into
an embedding from one site graph in its postcondition into the same reachable state. This way, a refinement lemma provides an enumeration of all the potential contexts for the precondition.

We now detail the seven different parts:
\begin{itemize}
\item \textbf{Detection of dead rules.} A rule is called dead, if there is no trace starting from the initial state in which this rule is applied. The analysis reports the list of the rules it has detected to be dead. Due to the over-approximation, it may happen that a dead rule is not discovered by the analysis. Yet, every rule that is reported as dead, is dead indeed.

In our example, we notice that the rule `\texttt{obs}' can never be trigered.

\item \textbf{Detection of dead agents.} An agent is called dead, if there is no trace starting from the initial state with at least one state in which this agent occurs. The analysis reports the list of the agents it has detected to be dead. Due to the over-approximation, it may happen that a dead agent is not discovered by the analysis. Yet, every agent that is reported as dead, is dead indeed.

In our example, there are no dead agent.

\item \textbf{Non-relational properties.} The analysis detects for each kind of site, the set of states this site can take.
Due to the over-approximation, the analysis reports a super-set of the set of the potential states. Yet, we are sure that a given site only take states within this set.

In our example, the site \texttt{cr} of \texttt{R} may be free, or bound to the site \texttt{n} of an agent \texttt{R}.

\item \textbf{Relational properties.} The analysis detects some relationships among the states of packs of sites within each agent, hence capturing potential valuations for local views \cite{Feret-ICCMSE2007,DanosEtAl-VMCAI08}.
 %Simple properties are reported in natural languages. More complex properties are reported in extension, by enumerating the states that these site can take simultaneously within a given instance of an agent.
Due to the over-approximation of the analysis, the analysis may fail in discovering a relationship. But each relationship that is found by the analysis is satisfied.

In our example, the states of the sites \texttt{c}, \texttt{cr}, \texttt{n}, and \texttt{x} of \texttt{R} are entangled with a relational property (othewise, we would have $5^2$ elements in the post-condition).


\item \textbf{Properties in connected agents.}
When two agents are connected, there may be a relation among the states of theirs respective sites.  This abstraction \cite{Feret:SASB2016} collects for each kind of bonds, the relation between the state of one site in the first agent and the state of one site in the second agent.  Due to the over-approximation, the analysis reports a super-set of the set of the potential pairs of states.

This abstraction aimed at capturing information about protein transportation.
It is quite common to model the location of a protein as the internal state of  a fictitious site. With such an encoding, it might be important to ensure that two connected proteins are always located in the same location. This abstraction focuses on this kind of properties.

\item \textbf{Properties of pairs of bonds.}

It might be interesting to know whether a protein can be bound to another protein twice simultaneously, and whether a protein can be bound to two instances of a same protein simultaneously. This abstraction \cite{Feret:SASB2016} captures this kind of constraint. It can be used to prove that some proteins do not polymerize.

In our example, when a \texttt{R} has its sites \texttt{cr} and \texttt{c} bound, they are necessarily bound to the same instance of \texttt{R}. The same statement holds for the sites \texttt{cr} and \texttt{n}.

\item \textbf{Properties of counters.}

\ttt{KaSa} is inferring the range of counters.

There are no counter in our previous example.
Let us consider the following one:
\begin{lstlisting}[language=kappa]
%agent:	A(x1{u p},x2{u p q},x3{u p},c{=0},d{=0})
%agent: B(x)

A(x1{u}) -> A(x1{p},c{+=3},d{+=2}) @1
A(x1{p}) -> A(x1{u},c{-=3},d{-=1}) @1
A(x2{u}) -> A(x2{p},c{+=2},d{+=1}) @1
A(x2{p}) -> A(x2{u},c{-=2},d{-=2}) @1
A(x2{p}) -> A(x2{q},c{+=1}) @1
A(x2{q}) -> A(x2{p},c{-=1}) @1
A(x3{u}) -> A(x3{p},c{+=3}) @1
A(x3{p}) -> A(x3{u},c{-=3}) @1
A(x1[.]),B(x[.]) -> A(x1[1],c{+=1}),B(x[1]) @1
A(x1[1]),B(x[1]) -> A(x1[.],c{-=1}),B(x[.]) @1
A(x2[.]),B(x[.]) -> A(x2[1],c{+=1}),B(x[1]) @1
A(x2[1]),B(x[1]) -> A(x2[.],c{-=1}),B(x[.]) @1
A(x3[.]),B(x[.]) -> A(x3[1],c{+=1}),B(x[1]) @1
A(x3[1]),B(x[1]) -> A(x3[.],c{-=1}),B(x[.]) @1

%init:	10	A()
%init: 10 B()
\end{lstlisting}

Typing the following command line:
\begin{verbatim}
KaSa reachability.ka --reset-all --compute-reachability-analysis
\end{verbatim}
we get in the section `Properties of counters' of the output what is prompted  in Fig.~\ref{fig:reachability_counters}. \ttt{KaSa} has inferred that the counter \texttt{c} is ranging from $0$ to $12$
. There is no information on counter \texttt{d} since its value has no lower bound and no upper bound.

By default, \ttt{KaSa} is using a relational numerical analysis based on a product between interval analysis \cite{CousotCousot76-1} and affine relationship analysis \cite{karr}. The product is approximate. It used a decision procedure described in \cite{feret:occurrence-counting}.

Other abstractions for counters are available for pedagogical purpose. For instance, the following command line:
\begin{verbatim}
KaSa reachability.ka --reset-all --compute-reachability-analysis
     --counters-accuract octagon
\end{verbatim}
will provide no property for counters (\eg see Fig.~\ref{fig:reachability_counters_oct}). \ttt{KaSa} has failed in bounding the range of the counter \texttt{c}
\end{itemize}




\begin{figure}[htbp]
\input{generated_img/LOG_mute.txt}
\caption{Reachability analysis of the model \texttt{reachbility.ka} with verbosity level ``Mute''.}
\label{fig:reachability_mute}
\end{figure}
%\begin{figure}[p]
%\input{generated_img/LOG_low.txt}
%\caption{Reachability analysis of the model \texttt{reachbility.ka} with verbosity level ``Low''.}
%\label{fig:reachability_low}
%\end{figure}
\begin{figure}[htbp]
\input{generated_img/LOG_medium_KO.txt}
\caption{Reachability analysis: one rule that cannot be applied yet, according to the bio-molecular species already constructed.}
\label{fig:reachability_medium_ko}
\end{figure}

\begin{figure}[htbp]
\input{generated_img/LOG_medium_OK.txt}
\caption{Reachability analysis: one rule successfully applied.}
\label{fig:reachability_medium_ok}
\end{figure}

\begin{figure}[htbp]
\input{generated_img/LOG_high_init.txt}
\caption{Reachability analysis: extensional description of initial states.}
\label{fig:reachability_high_init}
\end{figure}

\begin{figure}[htbp]
\input{generated_img/LOG_high_rule.txt}
\caption{Reachability analysis: extensional description of the new patterns  created when applying a rule.}
\label{fig:reachability_high_rule}
\end{figure}

\begin{figure}[htbp]
\input{generated_img/LOG_full.txt}
\caption{Reachability analysis: discovering new patterns force the analysis to apply some rules again, until reaching a fix-point.}
\label{fig:reachability_full}
\end{figure}

\begin{figure}[htbp]
\input{generated_img/LOG_counters.txt}
\caption{Reachability analysis: \ttt{KaSa} infers the range of counters.}
\label{fig:reachability_counters}
\end{figure}

\begin{figure}[htbp]
\input{generated_img/LOG_counters_oct.txt}
\caption{Reachability analysis: \ttt{KaSa} infers the range of counters.}
\label{fig:reachability_counters_oct}
\end{figure}

Now we describe the options that are available on this sub-tab.

The option \verb?--compute-reachability-analysis? can be used to switch on/off then reachability analysis.

The option \verb?--enable-every-domain? can be used to switch on every abstract domain, whereas the option \verb?--disable-every-domain? can be used to switch off every abstract domain.

The option \verb?--contact-map-domain? impacts the way side-effects are handled with during the analysis. In \verb?static? mode, we consider that every bond that occurs syntactically in the initial state, in the RHS of a rule, or in an introduction directive of a intervention, may be released by side-effects.
In \verb?dynamic? mode, only the bond that has been encountered so far during the analysis are considered.

The option \verb?--views-domain? can be used to switch on/off the views domains that combine the non-relational analysis and the relational analysis.

The option \verb?--counters-domain? can be used to switch on/off the analysis of the potential range of counters.

The option \verb?--counter-accuracy? can be used to select the abstraction for the potential range of counters. The domain \texttt{mi} consists in an approximate reduced product between interval analysis \cite{CousotCousot76-1} and affine relationships \cite{karr}. The reduction between these two domains, is obtained by applying the decision procedure that is described in \cite{feret:occurrence-counting}. The domain \texttt{octagons} infer a range for each variable, each sum and each difference among two variables. Although both domains have the same complexity, the product between intervals and affine constraints is more appropriate in the case of counters, since usually the state of more than two variables have to be related.

The option \verb?--double-bonds-domain? can be used to switch on/off the analysis of potential double bonds between proteins.

The option \verb?--site-across-bonds-domain? can be used to switch on/off the analysis of the relations among the states of the sites in connected proteins.


It is possible to get more details about the computation of the analysis by tuning the verbosity level of the view analysis:
\begin{itemize}
\item With the option \verb?--verbosity-level-for-reachability-analysis Mute?, nothing is displayed. Even the result of the analysis is omitted (eg.~see Fig.~\ref{fig:reachability_mute}).

\item With the option \verb?--verbosity-level-for-reachability-analysis Low?, only the result of the analysis is displayed (by default).

\item With the option \verb?--verbosity-level-for-reachability-analysis Medium?, the analysis also describes which rules are applied and in which order.

When trying to apply a rule, the analysis may detect that the rule cannot be applied yet because the precondition is not satisfied at the current state of the iteration (eg.~see Fig.~\ref{fig:reachability_medium_ko}). Otherwise, the analysis can apply the rule and update the state of the iteration accordingly (eg.~see Fig.~\ref{fig:reachability_medium_ok}).



\item With the option \verb?--verbosity-level-for-reachability-analysis High?, the analysis also describes which patterns are discovered.

In particular, at the beginning of the iteration, the analysis prompts the patterns of interest that occur in the initial state (eg.~see Fig.~\ref{fig:reachability_high_init}). Then, each time a rule is applied successfully, the analysis shows which new patterns have been discovered (eg.~see Fig.~\ref{fig:reachability_high_rule}).


\item When new patterns are discovered, then, it is necessary to apply again any rule that may operate over these patterns. With the following option:\\ {\hfill  \hspace*{2cm}\verb?--verbosity-level-for-reachability-analysis Full?, \hfill\mbox{}}\\
the analysis also describes which rules are awaken by the discovery of a new pattern (see Fig.~\ref{fig:reachability_full}).

\end{itemize}

The option \verb?--output-mode-for-reachability-analysis? can be used to tune the output of the analysis. The default mode is \verb?kappa?.
In mode \verb?raw?, patterns of interest are displayed extensionally.
In mode \verb?english?, properties of interest are explained in English.
The option \verb?--use-natural-language? can be used to switch on/off the translation of properties in natural language: when the option is disabled, each relationship is described in extension.

\section{Local traces}
\label{sec:local-traces}


\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kasa_4.png}
\caption{\KaSa~ graphical interface - sub-tab \texttt{Trace analysis}.}
\label{fig:kasa:3}
\end{figure}

Trace analysis is a refinement of reachability analysis that additionaly explains how one agent can go from a given view to another one, following a path that we call a local trace.
Thus the set of the local traces for a given agent can be described as a transition system among the views for a given agent: in this transition system, the nodes are local views; introduction arrows correspond to either initial states, or creation rules; transitions denote a potential conformation change of an agent, from one local views to another one, due to the application of a given rule.

We consider the following example:
\begin{lstlisting}[language=kappa]
%agent: P(a1{u,p},a2{u,p},b1{u,p},b2{u,p},g)
%agent: K(x)

%init: 1 P()
%init: 1 K()

'a1+' P(a1{u}) -> P(a1{p}) @1
'b1+' P(a1{p},b1{u}) -> P(a1{p},b1{p}) @1
'a1-' P(a1{p},b1{u}) -> P(a1{u},b1{u}) @1
'b1-' P(b1{p},g[.]) -> P(b1{u},g) @1
'a2+' P(a2{u}) -> P(a2{p}) @1
'a2-' P(a2{p},g) -> P(a2{u},g) @1
'b2+' P(a2{p},b2{u}) -> P(a2{p},b2{p}) @1
'b2-' P(b2{p},g) -> P(b2{u},g) @1
'P.K' P(a1{p},a2{p},b1{p},b2{p},g[.]),K(x[.]) -> P(a1{p},a2{p},b1{p},b2{p},g[1]),K(x[1]) @1
'P/K' P(a1{p},a2{p},b1{p},b2{p},g[1]),K(x[1]) -> P(a1{p},a2{p},b1{p},b2{p},g),K(x[.]) @1
\end{lstlisting}

Typing the following command line:

\begin{verbatim}
KaSa protein2x2.ka --reset-all --compute-local-traces
\end{verbatim}

will perform the trace analysis on the model \texttt{protein2x2.ka}, and produce
two dot format files \texttt{Agent\_trace\_K\_x\string^.dot} and \texttt{Agent\_trace.P.a1\_.a2\_.b1\_.b2\_.g\string^.dot}. The  output repository can be changed thanks to the command line options \texttt{-{}-output-directory} and \texttt{-{}-output-local-trace-directory}. Moreover, file names are made of the prefix \texttt{Agent\_trace}, followed by  the kind of protein and the list of the sites of interest (the symbol `\texttt{\string^}' denotes a binding state, and the symbol `\texttt{\_}' an internal state).

The transition system that describes the local traces for the agents of kind $P$ is descrided in Figure \ref{fig:trace-raw}. We notice that the nodes of this transition system are labelled with the states of the sites of $P$. The internal state of a site $x$ is denoted as $x\{u\}$ (meaning that the site $x$ has state $u$, whereas the binding state of a site $x$ is denoted as $x[.]$, when the site is free, and as $x[x.K]$ when the site $x$ is bound to the site $x$ of a given agent of kind $K$.

\begin{figure}[htbp]
\centering
\includegraphics[width=10cm]{generated_img/trace_raw.png}
\caption{Local traces for the \ttt{protein2x2.ka} model defined in Section~\ref{sec:local-traces}.}
\label{fig:trace-raw}
\end{figure}

We notice that the transition system that is given in Fig.~\ref{fig:trace-raw}  contains too many nodes. We can coarse-grain this transition system thanks to the following option:
\begin{center}
\texttt{-{}-use-macrotransitions-in-local-traces}.
\end{center}
Typing the following command line:

\begin{verbatim}
KaSa protein2x2.ka --reset-all --compute-local-traces
                   --use-macrotransitions-in-local-traces
\end{verbatim}

will perform the trace analysis on the model \texttt{protein2x2.ka}, and produce
two dot format files \texttt{Agent\_trace\_K\_x\string^.dot} and \texttt{Agent\_trace.P.a1\_.a2\_.b1\_.b2\_.g\string^.dot}. The name of the output repository can be changed thanks to the command line options \texttt{-{}-output-directory} and \texttt{-{}-output-local-trace-directory}.
This time, the files describe a coarse-graining of the corresponding transition systems.

For instance, the coarse-grained transition system for the local traces of the proteins of kind $P$ is given in Figure~\ref{fig:trace-macro}.  This  coarse-grained transition system is a compact implicit encoding of the transition system in Figure~\ref{fig:trace-raw}. It is obtained by exploiting the fact that locally, the behavior of the pair of states $a_1$ and $b_1$ is independent from the behavior of the pair of states $a_2$ and $b_2$, until these four sites are phosphorylated, so that the site $g$ can get bound.


More formally, in that transition system, some states are microstates (in a microstate, the state of each site is documented); some others are macrostates: (in a macrostate, the states of only a subset of site is documented).
Thus a macrostate $v^{\sharp}$ can be seen intensionally as a part  of a local view, but also extensionnaly as the set $\gamma(v^{\sharp})$ of the local views they are a subpart of. A microstate $v$ can be described by any sequence $(v_i^{\sharp})$ of macrostates providing that the intersection $\bigcap \gamma(v^{\sharp}_i)$ of the extensional denotation $\gamma(v^{\sharp}_i)$ of these macrostates $v^{\sharp}_i$ is equal to the singleton $\{v\}$;
moreover a transition between two microstates $v$ and $v'$ can be described by any transition between one macro state $v^{\sharp}$ and another one $v'{}^{\sharp}$, provided that there exists a sequence of macrostate $(v^{\sharp}_i)$ such that the sequence $(v^{\sharp},(v^{\sharp}_i))$ denotes the microstate $v$ and the sequence $(v'{}^{\sharp},(v^{\sharp}_i))$ denotes the microstate $v'$.

\begin{figure}[htbp]
\centering
\includegraphics[width=10cm]{generated_img/trace_macro.png}
\caption{Local traces for the \ttt{protein2x2.ka} model defined in Section~\ref{sec:local-traces}.}
\label{fig:trace-macro}
\end{figure}

Such coarse-grained transition system can be geometrically interpreted as a simplicial complex \cite{DBLP:conf/concur/FajstrupGR98}.

As a microstate could be decomposed into several sequences of macrostates (including the trivial sequence containing only the microstate itself), the system may jump spontaneously (by using a $\varepsilon$ transition) from one representation to another representation. This corresponds to the intersection between several simplexes in the corresponding simplificial complex.

Although the semantics of a coarse-grainged transition system is fully defined  by its labelled transitions, it is useful to annotate the graph by some information about the relation between the denotation of each macrostate. By default, we use hypertlinks to relate each macrostate $v$ (including each microstate)
 to the set of its immediate subparts $v'$. In such a hyperlink, $v$ is connected via a dotted arrow, whereas each immediate subpart is connected via a dashed arrow.

 More options are available in expert mode, but they are not documented yet.

\section{Contact map}

\begin{figure}[h]
\centering
\includegraphics[width=12cm]{img/kasa_5.png}
\caption{\KaSa~ graphical interface - sub-tab \texttt{Contact map}.}
\label{fig:kasa:4}
\end{figure}

The contact map of a model is an object that may help modelers checking the consistency of the rule set they use. The contact map is \emph{statically} computed and does not depend on kinetic rates, nor the concentration of the bio-molecular species in initial state.


Typing the following command line:

\texttt{KaSa abc.ka --reset-all --compute-contact-map}

will produce a dot format file named \texttt{contact.dot}.
The name of the output file and the directory can be changed thanks to the command line options \texttt{-{}-output-contact-map} and \texttt{-{}-output-directory}.
The directory is assumed to exist. The file will be overwritten if it exists. All the options related to the computation of the contact map can be accessed on the
sub-tab \texttt{Contact map} of the graphical interface (see Fig.~\ref{fig:kasa:4}).




The contact map summarises the different types of agent, their interface and the potential bindings between sites. It is an over approximation, thus if the contact map indicates a potential bond, it does not mean that it is always possible to reach a state in which two sites of these kinds are bound, but if the contact map indicates no bond between two sites, it means that it is NOT possible to reach a state in which two sites of these kinds are bound together.


The contact map for the \ttt{abc.ka} model  defined in Chapter~\ref{chap:abc} is given in Figure~\ref{fig:abc-contact}. On this map, we notice that there are three kinds of agent, namely $A$, $B$, and $C$.
Agents of kind $A$ have two sites $x$ and $c$, that bear no internal state (they appear in yellow only), agents of kind $B$ have one site $x$, that bears no internal state (they appear in yellow only), and agents of kind $C$ have two sites $x_1$ and $x_2$ with both a binding state and an internal state (they appear both in yellow and in green). We notice that when a site can bear both an internal state and a binding state, they are considered as two different sites in the contact map. Additionally, the contact map indicates that sites $x$ of the agents of kind $A$ can be bound to the site $x$ of an agent of kind $B$ and that sites $c$ of the agents of kind $A$ can be bound to the agents of kind $C$ either on the site $x_1$, or on the site $x_2$.

\begin{figure}[htbp]
\centering
\includegraphics[width=8cm]{generated_img/abc_contact.png}
\caption{Contact Map for the \ttt{abc.ka} model defined in Chapter~\ref{chap:abc}.}
\label{fig:abc-contact}
\end{figure}


There exist two accuracy levels for the contact map.
At low level of accuracy, the inference of the contact map is purely syntactic. The contact map summarizes the bonds that may occur in the right hand side of rules and in the initial bio-molecular species.
At high level of accuracy, the rules that are detected dead by the reachability analysis are not taken into account. Hence, only the bonds that may occur in the initial bio-molecular species, and in the rules that have not been proven dead by the static analysis are reported. As a matter of fact, the accuracy of the computation of the contact map at high level of resolution depends on the parameterization of the reachability analysis.

Let us illustrate this on a simple example. The file \texttt{contact.ka} has the following content:
\begin{lstlisting}[language=kappa]
%agent: A(x{c,n},z)

A(x{c}[.]) <-> A(x{n}[.]) @ 1,1
A(x{c}[.]),A(x{c}[.]) -> A(x{c}[1]),A(x{c}[1]) @1
A(x{n}[.]),A(x{n}[.]) -> A(x{n}[1]),A(x{n}[1]) @1
A(x{c}[1]),A(x{c}[1]) <-> A(x{n}[1]),A(x{n}[1]) @1,1
A(z[.]),A(x{c}[1],z[.]),A(x{n}[1]) -> A(z[2]),A(x{n}[1],z[2]),A(x{n}[1]) @1,1

%init: 10 A()
\end{lstlisting}

Firstly we compute the low resolution contact map by using the following instruction:
\begin{verbatim}
KaSa contact.ka --reset-all --compute-contact-map \
  --contact-map-accuracy-level Low
\end{verbatim}

We obtain the contact map that is drawed in Fig.~\ref{fig:cm-low-res}. We notice that the analysis reports a potential bond between the sites $x$ of any two agents of type $A$ and a potential bond between the sites $z$ of any two agents of type $A$. This is because such bonds occur in the right hand side of some rules of the model.


\begin{figure}[htbp]
\centering
\includegraphics[width=4cm]{generated_img/contact_map_low_res.png}
\caption{Low resolution contact map for the model \texttt{contact.ka}}
\label{fig:cm-low-res}
\end{figure}

Yet, bonds between two sites $z$ occur only in the last rule which turns out to be dead. Let us use the  high resolution contact map to check this property. We use the following instruction:
\begin{verbatim}
KaSa contact.ka --reset-all --compute-contact-map \
  --contact-map-accuracy-level High
\end{verbatim}

We obtain the contact map that is drawed in Fig.~\ref{fig:cm-high-res}. We notice that the potential bond between sites $z$ of agents $A$ has disappeared: the result of the analysis has been refined thanks to the constraints infered by the reachability analysis.

\begin{figure}[htbp]
\centering
\includegraphics[width=4cm]{generated_img/contact_map_high_res.png}
\caption{High resolution contact map for the model \texttt{contact.ka}}
\label{fig:cm-high-res}
\end{figure}

The proof that, the last rule of the model in the file \texttt{contact.ka} is dead relies on the abstract domain, that captures the potential relationships between states of sites in the pairs of agents, that are connected by a bond. Let us compute the high resolution contact map without this abstract domain:
\begin{verbatim}
KaSa contact.ka --reset-all --compute-contact-map \
  --contact-map-accuracy-level High --no-sites-across-bonds-domain
\end{verbatim}
We obtain the contact map that is given in Fig.~\ref{fig:cm-high-res-wo-rel}. The analysis has failed in proving that the last rule of the model is dead. As a matter of fact, the potential bond between sites $z$ of agents $A$ has not disappeared.


\begin{figure}[htbp]
\centering
\includegraphics[width=4cm]{generated_img/contact_map_high_res_wo_relations.png}
\caption{High resolution contact map for the model \texttt{contact.ka} when the abstract domain for the relations among the states of sites in pairs of bound agents is disabled.}
\label{fig:cm-high-res-wo-rel}
\end{figure}

The contact map may be refined with information about polymers.
When the commmand line option \texttt{--compute-potential-cycles} is used, {\KaSa} computes a superset of the bonds the number of occurences of which may not be uniformly bounded in paths within bio-molecular species. These bonds are then displayed in red in the contact map.

The computation of this subset is based on Tarjan's algorithm for the decomposition of a graph in strongly connected components \cite{Tarjan}. For this, we consider the graph of the potential succesion of bonds in bio-molecular species. The nodes of this graph are the oriented version of the potential bonds in the contact map (each potential bond is considered twice). Then there is an edge between two oriented bonds if the target of the first bond and the source of the second bond have the same agent type but different site names. Hence each edge is associated with a graph that is obtained by merging the graph associated to the source and the target of this edge, that is to say that each edge is associated with a graph made of three agents and two bonds (e.g.~see Fig.~\ref{fig:scc-graph}). We can notice that every path that may be repeated in bio-molecular species necessarily forms a cycle in this graph. The computation of all the elementary cycles in graph may be exponentially costly. Instead, we compute the strongly connected components which can be done in linear time (with respect to the sum among the number of nodes and the number of edges in the graph). The computation of the strongly connected components is enough, since an edge belongs to a cycle if and only if it belongs to a non trivial strongly connected component.

The file \texttt{scc\_abc.ka}
has the following content:
\begin{lstlisting}[language=kappa]

%agent: A(x,y)
%agent: B(x,y)
%agent: C(x,y)

A(x[.]),B(y[.]) -> A(x[1]),B(y[1]) @ 1
B(x[.]),C(y[.]) -> B(x[1]),C(y[1]) @ 1
C(x[.]),A(y[.]) -> C(x[1]),A(y[1]) @ 1

%init: 10 A()
%init: 10 B()
%init: 10 C()
\end{lstlisting}

In this example, arbitrary long chains and arbitrary long rings of agents may be formed (the site $x$ of each $A$ is either free or bound to the site $y$ of a $B$;  the site $x$ of each $B$ is either free or bound to the site $y$ of a $C$; and the site $x$ of each $C$ is either free or bound to the site $y$ of a $A$).

The graph that is associated to this model is given in Fig.~\ref{fig:scc-graph}.
\begin{figure}[htbp]
\centering
\includegraphics[width=10cm]{img/graph.png}
\caption{The graph about potential succession of bonds for the model \texttt{scc\_abc.ka}. Each bond in the model is encoded as a node. Each edge in the graph denotes a site-graph made of three agents.  }
\label{fig:scc-graph}
\end{figure}

Typing the following command line:
\begin{verbatim}
KaSa scc_abc.ka --reset-all --compute-potential-cycles
\end{verbatim}
will generate the contact map that is given Fig.~\ref{fig:cm-scc-abc}

\begin{figure}[htbp]
\centering
\includegraphics[width=4cm]{generated_img/scc_abc_contact.png}
\caption{The contact map for the model \texttt{scc\_abc.ka} with information about potential polymers. Every bond is drawed in red, since the analysis cannot bound their number of occurrences in paths in reachable bio-molecular compounds.}
\label{fig:cm-scc-abc}
\end{figure}

The accuracy of the detection of polymers may be tuned in two ways.
Firstly, it is parameterized of the accuracy of the contact map. Secondly, it may be refined by the reachability analysis in order to discard the couple of bonds that cannot be present successively in reachable bio-molecular compounds.

The file \texttt{scc\_relations.ka} contains the following model:
\begin{lstlisting}[language=kappa]
%agent: A(x,y)
%agent: B(x,y)

A(x[.],y[.]),B(y[.]) -> A(x[.],y[1]),B(y[1]) @1
A(x[.],y[.]),B(x[.]) -> A(x[1],y[.]),B(x[1]) @1

%init: 10 A()
%init: 10 B()
\end{lstlisting}

In this model, the sites $x$ and $y$ of a given instance of the agent $A$ cannot be bound simultaneously. This prevents the formation of polymers.

By default, the detection of polymers is using the result of the reachability analysis. Thus, the following instruction:
\begin{verbatim}
  KaSa --reset-all --compute-potential-cycles scc_relations.ka
\end{verbatim}
produces the contact map that is drawed in Fig.~\ref{fig:scc-relations-high}.
By default, the detection of polymers has used the result of the reachability analysis: since the bonds on the site $x$ and $y$ of each instance of the agent $A$ are mutually exclusive, no polymer may be formed.


\begin{figure}[h]
\centering
\includegraphics[width=4cm]{generated_img/scc_relations_contact_high.png}
\caption{The contact map for the model \texttt{scc\_relations.ka} with information about potential polymers. Since the bonds on the sites of $A$ are mutually exclusive, no polymer may be formed. This is infered by the analysis (no bond is colored in red).}
\label{fig:scc-relations-high}
\end{figure}

The refinement by the result of the reachability analysis can be disable by using the following instruction:
\begin{verbatim}
KaSa --reset-all --compute-potential-cycles \
   --polymer-detection-accuracy-level Low scc_relations.ka
\end{verbatim}
In this case, {\KaSa} produces the contact map that is given in Fig.~\ref{fig:scc-relations-low}. The analysis does know that the bonds of the sites of each agent of type $A$ are mutually exclusive. The bonds are drawed in red to warn about the potential formation of polymers of the model (this is a false alarm).


\begin{figure}[htbp]
\centering
\includegraphics[width=4cm]{generated_img/scc_relations_contact_low.png}
\caption{The contact map for the model \texttt{scc\_relations.ka} with information about potential polymers. Since the bonds on the sites of $A$ are mutually exclusive, no polymer may be formed. This is infered by the analysis (no bond is colored in red).}
\label{fig:scc-relations-low}
\end{figure}

The detection of polymer at high resolution also depends on the accuracy of the reachability analysis. The file \texttt{scc\_dimer.ka} contains the following model:
\begin{lstlisting}[language=kappa]
%agent: R(x,y,z)

R(x[.]),R(x[.]) -> R(x[1]),R(x[1]) @1
R(x[1],y[.],z[.]),R(x[1],y[.],z[.]) -> R(x[1],y[2],z[.]),R(x[1],y[.],z[2]) @1

%init: 10 R()
\end{lstlisting}

In this model, two agents of type $R$ may connect their sites $x$ together. Then, two agents connected via their sites $x$ may establish an asymetric bond between the site $y$ of the first one and the site $z$ of the second one.
As a consequence, whenever an agent of type $R$ has several sites bound, these sites are necessarily bound to the same instance of the agent $R$. Thus, there can be no polymer.

At low resolution, the detection of polymer fails in exploiting this property, and warns about potential polymers. Indeed, the following instruction:
\begin{verbatim}
KaSa --reset-all --compute-potential-cycles scc_dimer.ka \
  --polymer-detection-accuracy-level Low
\end{verbatim}
produces the contact map that is drawed in Fig.~\ref{fig:scc-dimer-low}.


\begin{figure}[htbp]
\centering
\includegraphics[width=4cm]{generated_img/scc_dimer_contact_low.png}
\caption{The contact map for the model \texttt{scc\_dimer.ka} with information about potential polymers at low resolution. The analysis fails in proving the lack of polymers (bonds are colored in red).}
\label{fig:scc-dimer-low}
\end{figure}

At high level of resolution, the analysis for the detection of potential polymers successfully prove the lack of polymers. The following instruction:
\begin{verbatim}
KaSa --reset-all --compute-potential-cycles scc_dimer.ka
\end{verbatim}
produces the contact map that is given in Fig.~\ref{fig:scc-dimer-high}. The analysis has successfully proven the lack of polymers (no bond is colored in red).

\begin{figure}[htbp]
\centering
\includegraphics[width=4cm]{generated_img/scc_dimer_contact_high.png}
\caption{The contact map for the model \texttt{scc\_dimer.ka} with information about potential polymers at high resolution. The analysis successfully proves the lack of polymers (no bond is colored in red).}
\label{fig:scc-dimer-high}
\end{figure}

In order to illustrate that the accuracy of the analysis relies in this example on the capability for the analysis to exploit properties of double bonds. We disable the double bond domain. The following instruction:
\begin{verbatim}
KaSa --reset-all --compute-potential-cycles scc_dimer.ka \
 --no-double-bonds-domain
\end{verbatim}
produces the contact map that is given in Fig.~\ref{fig:scc-dimer-high-no-double}. Without the capability to express and prove that whenever an agent of type $R$ is bound twice, it is necessarily bound twice to the same agent instance. The analysis fails in proving the absence of polymer. Thus, it warns about potential polymers, by drawing the edges in red.





\begin{figure}[htbp]
\centering
\includegraphics[width=4cm]{generated_img/scc_dimer_contact_high_no_double_bonds.png}
\caption{The contact map for the model \texttt{scc\_dimer.ka} with information about potential polymers at high resolution but without the analysis of double bonds. The analysis cannot infer the fact that whenever two sites of an agent $R$ are bound, they are necessarily bound to the same instance of an agent. Thus, it cannot infer the lack of polymers. (bonds are colored in red)}
\label{fig:scc-dimer-high-no-double}
\end{figure}

\section{Influence map}

The influence map of a model is an object that may help modelers checking the consistency of the rule set they use.

Typing the following command line:

\texttt{KaSa abc.ka --reset-all --compute-influence-map}

will produce a dot format file named \texttt{influence.dot}.
The name of the output file and the directory can be changed thanks to the command line options \texttt{-{}-output-influence-map} and \texttt{-{}-output-directory}.
The directory is assumed to exist. The file will be overwritten if it exists.  All the options related to the computation of the influence map can be accessed on the sub-tab \texttt{Influence map} of the graphical interface (see Fig.~\ref{fig:kasa:5}). Two formats are available for the output: influence map can be generated in DOT or HTML format. The format can be choosen thanks to the command line option \texttt{-{}-influence-map-format}.

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kasa_6.png}
\caption{\KaSa~ graphical interface - sub-tab \texttt{Influence map}.}
\label{fig:kasa:5}
\end{figure}

Unlike the \emph{dynamic} influence network, the influence map is \emph{statically} computed and does not depend on kinetic rates nor the quantities in initial conditions. It describes how rules may potentially influence each other during a simulation. \KaSa~will produce a dot format file containing the influence relation over all rules and observables of the model. The produced graph visualised using a circular rendering\footnote{One may use for instance the \ttt{circo} program that is part of the \textit{graphviz} suite.} is given in Figure~\ref{fig:kasa-abc-im}. Observables are represented as circular nodes and rules as rectangular nodes. The labels of the nodes are either the label of the rule or of the observable (if available), otherwise they are made of a unique identifier allocated by \KaSa~followed by the Kappa definition of the rule/observable.
Edges are decorated with the list of embeddings (separated by a semi-colon) allowing the identification of agents in both rules' right hand sides/left hand sides.
More precisely, for positive influences,  the notation $[i\rar j]$ denotes a pair of embeddings from the agent number $i$ of the origin{\textquotesingle}s right hand side and from the agent number $j$ of the target{\textquotesingle}s left hand side and the notation $[i\star \rar j]$ denotes a pair of embeddings from an agent attached to the agent number $i$  of the origin{\textquotesingle}s left hand side, which have been freed by side effect  and   from the agent number $j$ of the target{\textquotesingle}s left hand side; for negative influences,  the notation $[i\rar j]$ denotes a pair of embeddings from the agent number $i$ of the origin{\textquotesingle}s left hand side and from the agent number $j$ of the target{\textquotesingle}s left hand side and the notation $[i\star \rar j]$ denotes a pair of embeddings from an agent attached to the agent number $i$  of the origin{\textquotesingle}s left hand side, which have been freed by side effect  and   from the agent number $j$ of the target{\textquotesingle}s left hand side;
 Observables have no influence, but they can be influenced by rules, if the rule can increase or decrease their value.


\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=15cm]{generated_img/abc_influence.png}
   \caption{The influence map of the \ttt{abc.ka} model defined in Chapter~\ref{chap:abc}. Edge labels denote embeddings with the convention that
the notation $[i\rar j]$, in a positive influence, denotes a pair of embeddings from the agent number $i$ of the origin{\textquotesingle}s right hand side and from the agent number $j$ of the target{\textquotesingle}s left hand side;
the notation $[i\rar j]$, in negative influence,  denotes a pair of embeddings from the agent number $i$ of the origin{\textquotesingle}s left hand side and from the agent number $j$ of the target{\textquotesingle}s left hand side;
the notation $[i\star \rar j]$, whatever the influence is positive of negative,  denotes a pair of embeddings from an agent attached to the agent number $i$  of the origin{\textquotesingle}s left hand side, which have been freed by side effect  and   from the agent number $j$ of the target{\textquotesingle}s left hand side. }
   \label{fig:kasa-abc-im}
\end{figure}

More formally, consider the rules $r:L\rar R$ and $s:L'\rar R'$. One wishes to know whether it is possible that the application of rule $r$ over a graph $G$ creates a new instance of rule $s$ (which is called a positive influence and that is described by green arrows in the influence map), or destroy a previous instance of rule $s$ (which is called negative influence and that is described by red arrows in the influence map).
In Fig.~\ref{fig:imbis}, we illustrate the construction of positive influences due to overlap of the left hand side of a rule and the right hand side of another rule on some sites that are modified by the former one.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
\includegraphics[width=8cm]{img/im.png}
   \caption{Computation of the influence of the top rule on the rule below: the right hand side of the first rule embeds in a common term with the left hand side of the second rule. It results that the first rule has a positive influence on the second.}
   \label{fig:imbis}
\end{figure}

The current implementation has the following limitations:
\begin{itemize}
\item Currently, only observables that are defined as patterns are taken into account.
\item Not atomic observables which are defined as algebraic expressions are not taken into account yet. The observables are ignored.
\item The influence map does not take into account indirect influences due to interventions (which could arises when the application of a rule triggers a intervention which would create some agents or increase/decrease the value of some variables).
\item Token are not taken into yet. They are currently ignored.
\item Positive/negative influence of time is not taken into account either.
\end{itemize}

Lastly, KaSa\ computes an over-approximation of the influence map. They may show an influence despite the fact that there can be no actual one. But if it shows no influence it means that either there are NO such influence, or that we are in a case that is not covered yet as itemised previously.

Three levels of precision are available: \texttt{Low}, \texttt{Medium}, and
\texttt{High}. The level of precision can be changed thanks to the command line option \texttt{-{}-influence-map-accuracy-level}.

At low precision, an influence is detected if one rule change at least one bit of information (the internal state of a site, the binding state of a site), in favor/defavor of the application of another rule. This abstraction level ignores completely the context of application of rules, and just focuses on modifications.

At medium precision, the analysis checks that both rules have a common context.

At high precision, the analysis checks that such common context is realizable taking into account the species that have been declared as initial states
and the potential introduction of species in interventions. High resolution influence is parameterized by the accuracy of the reachability analysis.
It may happen that a given context is infeasible, but that this is not detected by the analysis.

Let us illustrate these three levels of accuracy by a case study.

We consider the following model.
\begin{lstlisting}[language=kappa]
  %agent: A(w~u~p,x~u~p,y~u~p,z~u~p)

  A(x~u) -> A(x~p) @1
  A(x~p,y~u) -> A(x~p,y~p) @1
  A(y~p,z~u) -> A(y~p,z~p) @1
  A(x~u,z~p,w~u) -> A(x~u,z~p,w~p) @1
  A(x~u,z~u) -> A(x~u,z~p) @1
  A(x~p,w~p) -> A(x~p,w~u) @1

  %init: 10 A()
\end{lstlisting}

The low resolution influence map is given in Fig.~\ref{fig:low-res}.
There is a positive arc (in green) from a rule to another one whenever the application of the former pushes at least one bit of information towards the application of the later; whereas there is a negative arc (in red) from a rule to another one whenever the former pulls at least one bit of information away from the application of the later.

The medium resolution influence map is given in Fig.~\ref{fig:medium-res}.
Every arc corresponding to incompatible contexts has been removed.
In our example, these are the arcs from the rule $3$ and the rule $5$ (in both direction). Despite the fact that the rule $3$ may phosphorylate the site \texttt{w} which is required to apply the rule $5$, no instance of the rule $5$ may be applied thanks to the application of the rule $3$ right after, because after the application of the rule $3$ the state of the site $x$ is necessarily unphosphorylated, whereas it has to be phosphorylated for the rule $5$ to be applied. The same kind of explanation holds to remove the arc from the rule $5$ to the rule $3$.

There are some structural invariants in these models. We give in Fig.~\ref{fig:reachability_influence} the log of the computation of the high resolution contact map. It turns out that whenever the site \texttt{y} of an agent is phosphorylated, then the site \texttt{x} of this protein is phosphorylated as well. Thus we can deduce that the positive arc from the rules $2$ and $3$, and the negative arcs from the rules $2$ and $4$ (in both direction) are false positive unless we change the set of the species in the initial state or in the interventions. Thus we obtain the high resolution influence map given in Fig.~\ref{fig:high-res}.





\begin{figure}[htbp]
\begin{center}
\includegraphics[width=10cm]{generated_img/inf_map_low_res.png}
\caption{Low resolution influence map.}
\label{fig:low-res}
\end{center}
\end{figure}
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=10cm]{generated_img/inf_map_medium_res.png}
\caption{Medium resolution influence map.}
\label{fig:medium-res}
\end{center}
\end{figure}
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=10cm]{generated_img/inf_map_high_res.png}
\caption{High resolution influence map.}
\label{fig:high-res}
\end{center}
\end{figure}

\begin{figure}[t]
\input{generated_img/LOG_influence_reachability.txt}
\caption{Log of the reachability analysis.}
\label{fig:reachability_influence}
\end{figure}

\chapter{The \KaDE~ODEs generator}

\section{General usage}

From a terminal window, \KaDE~can be invoked by typing the following command line:
\ITE{
\item[\$] \ttt{KaDE file\_1 ... file\_n  [option]}
}
where \ttt{file\_i} are the input Kappa files containing the rules, initial conditions and observables (see Chapter~\ref{chap:kappa}).

All the options are summarised as follows:
\input{generated_img/KaDE_options.txt}

Orders in option matter, since they can be used to toggle on/off some functionalities or to assign a value to some environment variables.
The options are interpreted from left to right.

\section{Graphical interface}

\subsection{Launching the interface}

The graphical interface can be launched by typing the following command line:
\ITE{\item[\$] \ttt{KaDE}}

without any option.

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kade_0.png}
\caption{\KaDE~ graphical interface - sub-tab \texttt{Data set}.}
\label{fig:kade:0}
\end{figure}

\subsection{The areas of interest}

There are five different areas of importance in the graphical interface:
\begin{enumerate}
\item On the top left of the window, a button allows for the selection between the Normal and the Expert mode (other modes may be available if activated at compilation).
In expert mode, more options are available in the graphical interface.
\item On the top center/right, some button allows for the selection of the tab. There are currently seven sub-tabs available: \texttt{Data set}, \texttt{Output}, \texttt{Semantics}, \texttt{Integration settings}, \texttt{Model reduction}, \texttt{Static analysis}, \texttt{Debug mode}. The last two tabs are availanle only in expert mode (which can be selected on the top-left of the window).

\item Center: The options of the selected sub-tab are displayed and can be tuned.

Contextual help is provided when the mouse is hovered over an element.
The interface will store the options that are checked or filled and the order in which they have been selected.
When launched, the analysis interprets these options in the order they have been entered.
Some options appear in several sub-tabs. They denote the same option and share the same value.

\item File selector: The file selector can be used to upload as many Kappa files as desired. The button '\texttt{Clear}' can be used to reset the selection of files.
\item Bottom: Some buttons are available. The button '\texttt{Quit}' can be used to leave the interface. The button '\texttt{Reset to default}' tunes all the options to their default value. The button '\texttt{Import options}' can be used to restore the value of the options as saved during a previous session of the graphical interfaces. The button '\texttt{Save options}' can be used to save the value of the options for a further session. The button '\texttt{Launch analyze}' launch \KaDE\ with the current options.

Importantly, options are saved automatically under various occasions. Thus, it is possible to restore the value of the options
before the last reset, before the last quit, or before the last analysis.
\end{enumerate}

Two fields define the repository and the name of the output:
\begin{itemize}
\item The field \texttt{-d} sets  the repository where output file are written. \KaDE~will create this repository, if it does not exist.
\item The field \texttt{-{}-output} sets the name of the output file.
The following extension will be added automatically according to the choice of the backend format: ".net" in DOTNET format, ".mws" in Maple, ".nb" in Mathematica, ".m" in Matlab and Octave, and ".xml" in SBML. When the output file already exists, {\KaDE} will ask for confirmation before overwritting it, unless the tool is set in batch mode (e.g.~see Sect.~\ref{kade:debug}).
\end{itemize}
Both fields may be modified from every sub-tab.




\subsection{The sub-tab \texttt{Data set}}

The sub-tab \texttt{Data set} (see Fig.~\ref{fig:kade:0}) contains the options to tune the time range for the numerical integration and the frequency of sample plots. These fields are used only in Maple, Mathematica, Matlab, and Octave backend formats.
They are ignored in SBML and DOTNET backend formats.

The following options are available:
\begin{itemize}
\item The field \texttt{-{}-initial} defines the starting date of the simulation.
\item The field \texttt{-l} defines the final date of the simulation.
\item The field \texttt{-p} defines the time interval between consecutive plots.
\end{itemize}

\subsection{The sub-tab \texttt{Output}}

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kade_1.png}
\caption{\KaDE~ graphical interface - sub-tab \texttt{Output}.}
\label{fig:kade:1}
\end{figure}


The sub-tab \texttt{Output} (see Fig.~\ref{fig:kade:1}) contains the names of the output files and their format.

The following options are available:
\begin{itemize}
\item The field \texttt{-{}-ode-backend} allows for the choice among the different backend formats among DOTNET, Maple, Mathematica, Matlab, Octave and SBML.
\item The field \texttt{-{}-output-plot} sets the name of the file where the plots will be dumped when it applies. Only the Maple, Mathematica, Matlab and Octave dump plots. The option is ignored in the other backend formats.
\item The option \texttt{-{}-(no)-constant-propagation} switches on/off constant propagation.
\item The option \texttt{-{}-(no)-show-reactions} annotates each expression in the output file, with the Kappa rule and the reaction that have generated this contribution.
\item The option \texttt{-{}-(no)-smash-reactions} identifies multiple occurrences of a same reaction in the reaction network, and sums up  their contribution into a single reaction.
\end{itemize}

\subsection{The sub-tab \texttt{Integration settings}}

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kade_3.png}
\caption{\KaDE~ graphical interface - sub-tab \texttt{Integration settings}.}
\label{fig:kade:3}
\end{figure}

The sub-tab \texttt{Integration settings} (see Fig.~\ref{fig:kade:3}) contains the parameters to guide the numerical integration engine. Except the option \texttt{-{}-smash-reaction}, these options are ignored in the SBML and the
DOTNET backend format.

The following options are available:
\begin{itemize}
  \item The option \texttt{-{}-compute-jacobian} switches on the computation of the Jacobian of the system of ordinary differential equations.
  The Jacobian is computed symbolically. It speeds up the numerical integration. The computation of the Jacobian is implemented only in two backend formats:  Matlab and Octave. Other formats will ignore this option.
  \item The option \texttt{-{}-non-negative} can be used to force concentration to have a non negative value during numerical integration.
  The computation of the Jacobian is implemented only in two backend formats:  Matlab and Octave. Other formats will ignore this option.
  \item The field \texttt{-{}-initial-step} tunes the initial integration step.
  This field is used only in Maple, Mathematica, Matlab, and Octave backend formats.
  It is ignored in SBML and DOTNET backend formats.
  \item The field \texttt{-{}-max-step} tunes the maximal size of integration steps. This field is used only in Maple, Mathematica, Matlab, and Octave backend formats.
  It is ignored in SBML and DOTNET backend formats.
  \item The field \texttt{-{}-relative-tolerance} defines the relative numerical error tolerance in integration engines. This means that numerical errors cannot go beyond a bound that is proportional to the concentration of the bio-molecular species. This field sets the value of the proportionality coefficient.   This field is used only in Maple, Mathematica, Matlab, and Octave backend formats.
  It is ignored in SBML and DOTNET backend formats.
  \item The field \texttt{-{}-absolute-tolerance} defines the absolute numerical error tolerance in integration engines. This means that numerical errors cannot go beyond the value of that field.  This field is used only in Maple, Mathematica, Matlab, and Octave backend formats. It is ignored in SBML and DOTNET backend formats.
  \item The field \texttt{-{}-output-plot} defined the csv file where the values of the sample plots will be printed. This field is used only in Maple, Mathematica, Matlab, and Octave backend formats.
  It is ignored in SBML and DOTNET backend formats.
  \item The option \texttt{-{}-smash-reaction} gathers isomorphic reactions before generating the network or the system of ordinary differential equations (while summing their rates). This option is used in every backend format.
  \item The field \texttt{-{}-initial} defines the starting date of the simulation. This field is used only in Maple, Mathematica, Matlab, and Octave backend formats.
  It is ignored in SBML and DOTNET backend formats.
  \item The field \texttt{-l} defines the final date of the simulation. This field is used only in Maple, Mathematica, Matlab, and Octave backend formats.
  It is ignored in SBML and DOTNET backend formats.
  \item The field \texttt{-p} defines the time interval between two plots. This field is used only in Maple, Mathematica, Matlab, and Octave backend formats.
  It is ignored in SBML and DOTNET backend formats.
\end{itemize}

\subsection{The sub-tab \texttt{Debug}}
\label{kade:debug}
In expert mode, the last sub-tab provides options to tune the amount of debugging information that is displayed.

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kade_5.png}
\caption{\KaDE~ graphical interface - sub-tab \texttt{6\_debug\_mode}.}
\label{fig:kade:6}
\end{figure}

The following options are available:
\begin{itemize}
\item The option \texttt{-{}-(no)-show-time-advance} includes some
instructions in the output file, so as to track the progress during numerical integration in the Maple, Mathematica, Matlab, and Octave backend.
This option is ignored in the other backend format.

\item The field \texttt{-{}-(no)-print-efficiency} provides some information about the CPU time that has been used to generate the set of reactions and about the size of the initial and reduced models.

\item The option \texttt{-{}-(no)-backtrace} provides more/less information about internal exceptions.
\item The option \texttt{-{}-(no)-glutonny} tunes the parameters of the garbage collector.
\item The field \texttt{-mode} allows for the choice among batch and interactive mode. In interactive mode, {\KaDE} always asks  permission to  overwrite files. In batch mode, {\KaDE} may overwrite output files, without permission.
\end{itemize}



\section{Differential semantics}
\label{sec:differential semantics}

\subsection{From rules to reactions}

In Kappa, rules may be more and less refined \cite{DanosFFHK08,DBLP:journals/tcsb/DanosFFHK09}, according to their preconditions.

\begin{figure}[t]
\begin{minipage}{\linewidth}
    \centering\scalebox{0.7}%
    {\includegraphics{gkappa_img/sect1-bind.pdf}}
  \end{minipage}
  \caption{Proteins \texttt{K} and \texttt{S} may bind.}
  \label{fig:sec1:bind}
\end{figure}
\begin{figure}[t]
\begin{minipage}{\linewidth}
\centering\scalebox{0.7}{\includegraphics{gkappa_img/sect1-phos.pdf}}
\end{minipage}
\caption{The protein \texttt{K} may activate the protein \texttt{S}.}
\label{fig:sec1:phos}
\end{figure}
\begin{figure}[t]
\centering\hspace*{5mm}\includegraphics[width=1.3\linewidth]{gkappa_img/ref.pdf}
  \caption{From rules to reactions. The rule in Fig.~\ref{fig:sec1:bind} is refined into two reactions according to whether the site \texttt{r} of the protein \texttt{S} is phosphorylated or not.}
  \label{fig:refinement}
\end{figure}

Consider the following two rules:
\begin{lstlisting}[language=kappa]
'bind'  K(r),S(l) -> K(r!1),S(l!1) @k
'phos'  K(r!1),S(l!1,r~u) -> K(r!1),S(l!1,r~p) @kp
\end{lstlisting}




 The first rule (e.g.~see Fig.~\ref{fig:sec1:bind}) stipulates that proteins of type \texttt{K} and proteins of type \texttt{S} may bind via their respective right and left sites. The second rule (e.g.~see Fig.~\ref{fig:sec1:phos})  stipulates that a protein \texttt{S} bound to a protein \texttt{K} may be activated (on its right site).

It is worth noticing that the first rule may be applied in two different contexts, according to whether or not the right site  of the protein on the right  is already phosphorylated, or not. It follows the refinement that is depicted in Fig.~\ref{fig:refinement}.

In general, each rule may be refined into a (potentially infinite) multi-set of reactions over fully specified site-graphs.
%In the differential semantics, rule applications preserve disconnectedness, unless it is specified explicitly in the model. Thus each connected component in the left hand side is refined separately.
Each connected component in a reaction denotes an instance of a bio-molecular species. For every bio-molecular species $S$, a reaction $R_1 + \ldots + R_m {\rightarrow} P_1 + \ldots + P_n$ gives the following contribution to the derivative of the concentration of $S$,

\newcommand{\myfrac}[2]{\frac{\strut \displaystyle #1}{\strut \displaystyle #2}}
\newcommand{\diff}[1]{\myfrac{\mathrm{d}#1}{\mathrm{d}t}}

\begin{equation*}
  \diff{[S]} \stackrel{+}= \sum_r \gamma(r)\cdot[r,R]\cdot\Delta(R,S)\cdot [R_1] \cdot \ldots \cdot [R_m]
\end{equation*}
where:
\begin{enumerate}
  \item $[r,R]$ is the number of different ways to induce the reaction $R$ from the rule $r$;
  \item $\gamma(r)$ is the corrected rate of the rule $r$ (a fraction of the rate of the rule $r$ is taken according to a choice among three  conventions defining how automorphisms are taken into account);
  \item and $\Delta(R,S)$ is the difference between the number of occurrences of the species $S$ in the sequence $P_1,\ldots,P_n$ and
the one in the sequence $R_1,\ldots,R_m$.
 \end{enumerate}

 This defines the ODE semantics of Kappa models.

\subsection{Semantics convention}

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kade_2.png}
\caption{\KaDE~ graphical interface - sub-tab \texttt{2\_semantics}.}
\label{fig:kade:2}
\end{figure}

\subsubsection{Rate constant conventions}





The options in the sub-tab \texttt{Semantics} allow for the choice among several possibilities for the meaning of the ODEs variables and for the meaning of the rate constants.


 \KaDE~corrects the rate constant of each  according to a convention about the number of automorphisms in this rule. {\KaDE}~offers the choice among three conventions:
\begin{enumerate}
  \item with the convention \texttt{KaSim}, there is no correction, as it is done in the simulator;
  \item with the convention \texttt{Divide\_by\_the\_number\_of\_autos\_in\_lhs}, each rate constant is divided by the number of automorphisms in the lhs of the rule, as it was done in previous version of the simulator;
  \item  with the convention \texttt{Biochemist}, each rate constant is divided
  by the number of the automorphisms in the lhs, that also induces an automorphism over the agents that are preserved in the rhs of the rule (more formally, an automorphism in the lhs of a rule is taken into account only if its restriction to the part that is common to the lhs and the rhs of the rule, can be extended to an automorphism of the rhs of the rule). In particular, only automorphisms that  map degraded proteins, if any, to degraded proteins, are considered. Indeed this convention account for the automorphisms of the left hand side of rules which identifies the agents that cannot be ditinguished from a mechanistic point of view.
\end{enumerate}

  Consider the following rule:
    \begin{lstlisting}[language=kappa]
A(u,r~u),A(u,r~u),A(u,r~u),A(u,r~u) -> A(u!1,r~u),A(u!1,r~u),A(u,r~u),A(u,r~p) @ 'k'
    \end{lstlisting}
which is depicted as follows:
\begin{center}
  \scalebox{0.8}{\includegraphics{gkappa_img/auto.pdf}}
\end{center}

  with the first convention (that is the one of the simulator), rates of rules are not corrected, hence the effective rate of this rule is $k$;
  with the second one, rates are divided by the number of automorphisms in the left hand side of rules (here $4!$ that is to say $24$); the third convention accounts only for the permutations among the agents that are undistinguishable from a mechanistic point of view: rates are divided by the number of automorphisms in the left hand side of rules that also induce automorphisms of the right hand side  (here $2$).

  \subsubsection{Ambiguous molecularity}

The differential semantics is defined as the limit of the stochastic semantics when the temperature diverges toward the infinity. Thus a rate constant stands indeed for a function mapping the temperature to an effective rate constant the expression of which depends on the arity of the reaction. Even if the unary rate and the binary rate of a rule may be equal for a given temperature, it is never the case at all temperatures. Another insight is that rate constants for a unary reaction and rate constants for a binary reaction are not expressed in the same physical units.

To account for this, {\KaDE} never applies a binary rule in a
  unary context, unless two rate constants have been provided explicitly.

\begin{figure}[t]
  \hfill\begin{minipage}{0.9\linewidth}
  \scalebox{0.7}{\includegraphics{gkappa_img/amb_noamb.pdf}}
\end{minipage}\hfill\mbox{}
\caption{The rule \texttt{A(x),A(x) -> A(x!1),A(x!1)} may bind two agents that are already in the same connected component, only if a second rate constant is given explictly.}
\end{figure}
  Let us give an example. We consider the agent type \texttt{A} with two binding sites \texttt{x} and \texttt{y}. We assume that two sites \texttt{x} (in different \texttt{A}s) may be bound pair-wise and that two sites \texttt{y} (in different \texttt{A}s) may be bound pair-wise. Both following rules:
\begin{lstlisting}[language=kappa]
A(x),A(x) -> A(x!1),A(x!1) @ 1
A(x),A(x) -> A(x!1),A(x!1) @ 1{0}
\end{lstlisting}
  will behave the same: they both apply to the following mixture
\begin{lstlisting}[language=kappa]
A(x,y),A(x,y)
\end{lstlisting}
  but not to the following one:
\begin{lstlisting}[language=kappa]
A(x,y!2),A(x,y!2)
\end{lstlisting}

  So as to allow the rule to form a bond within the two agents of the dimer, the following rule:
  \begin{lstlisting}[language=kappa]
A(x),A(x) -> A(x!1),A(x!1) @ 1{1}
  \end{lstlisting}
   shall be used instead.

  This way, when a rule is given with one rate constant only, the connected components in its left hand side have to be refined into pair-wisely disjoint bio-molecular species. When a rule is binary and when it is given with two rate constants,  it may be apply in a unary context (which consists in embedding its left hand side into a single bio-molecular species) with the second rate constant, or in a binary context (which consists in embedding each connected component in its left hand side into two disjoint bio-molecular species (which may be two isomorphic copies of the same species)).

  \subsubsection{Embeddings VS occurrences}

In a Kappa file, a pattern may denote two different quantities.
At initialisation, a pattern denotes an occurence of a bio-molecular species. In an algebraic expression (which includes functional rates,
stoichiometric coefficients for tokens, observables), a pattern denotes a number of embeddings from this pattern to a mixture.

Formally, we define the number (resp.~the concentration) of embeddings from a pattern to a mixture (resp.~to a concentration function) as
the sum, for each bio-molecular species,
 of the number of occurrences (resp.~concentration) of that bio-molecular species and the number of occurrences of the pattern in that bio-molecular species. We also define the number (resp.~the concentration) of occurrences of a pattern in a mixture (resp.~in a concentration function) as the quotient between the number (resp.~the concentration) of embeddings from this pattern to a mixture (resp.~to a concentration function) and the number of automorphisms in this pattern.

To illustrate this, we assume that the file \texttt{occ.ka} contains the following code:
\lstinputlisting[language=kappa]{kappa/occ.ka}
We use the following command line to get the value of the observable:
\ITE{\item[\$] \ttt{KaSim} occ.ka -l 1 -p 0.5 -o occ.csv}

The file \texttt{csv} contains the following data set:
{\lstset{numbers=none}\lstinputlisting{generated_img/occ.csv}}
{\lstset{numbers=left}}

We notice that KaSim indicates $20$ for the quantities of dimers.
This accounts for the fact that each dimer satisfies two automorphisms.

The command-line option \texttt{-{}-count [Embeddings | Occurrences]}
changes the meaning of the variables that occur in the differential equations. The choice has no impact on the quantities that are plot. Introduced bio-molecular species are always introduced in
concentration of occurrences, and patterns in algebraic expressions always denote concentration of embeddings. It just changes the meaning of the variables that are used internally in the differential equations.

\subsubsection{Polymers}

In case of polymerisation, the size of the bio-molecular species is potentially  unbounded and there may be an infinite amount of differential equations (this is the case even if there is no agent synthesis, since the initial state is given in concentration, and not in occurrence number). In such a case, {\KaDE} will not terminate. Yet it is possible to truncate the system of ordinary differential equations: the command-line option \texttt{-{}-truncate} specifies an upper bound to the number of agents in the bio-molecular species. Each reaction that would involve a larger bio-molecular species is discarded.

For instance, we can consider the model \texttt{poly.ka} that is defined as follows:
\begin{lstlisting}[language=kappa]
  %agent: A(l,r)
  %init: 10 A()
  A(r), A(l) -> A(r!1),A(l!1) @ 1
\end{lstlisting}

The command line:
\ITE{\item[\$] \ttt{KaDE} poly.ka}
will not terminate, wheareas the following one:
\ITE{\item[\$] \ttt{KaDe} poly.ka --truncate 10}
will.


\subsubsection{Equivalent sites}

\label{sec:kade:ex}

In BNGL, the interface of a given agent may include several occurrence of a given site name. These sites have exactly the same capabilities of interaction. This feature provides a convenient syntactic construction to describe models even more compactly, at the cost of having to deal with more complex structures (detecting embeddings between such site-graphs may be very difficult).

In Kappa, the interface of every agent is made of pair-wisely distinct site names. Yet it may happen that some sites have exactly the same capabilities of interaction. {\KaDE} can infer this property and use it to derive a more compact system of differential equations \cite{Feret-MFPSXXVII,CAMPORESI201073,Feret201545}.


Consider the following model:
\begin{lstlisting}[language=kappa]
%agent: A(x,y)
%init: 10 A()

A(x,y),A(x,y) -> A(x!1,y),A(x!1,y) @1
A(x,y),A(x,y) -> A(x,y!1),A(x,y!1) @1
A(x,y),A(x,y) -> A(x!1,y),A(x,y!1) @2
\end{lstlisting}

\begin{figure}[t]
  \begin{minipage}{0.3\linewidth}
    \centering\scalebox{0.7}{\includegraphics{gkappa_img/symtt.pdf}}
  \end{minipage}\hspace*{5mm}
  \begin{minipage}{0.3\linewidth}
    \scalebox{0.7}{\includegraphics{gkappa_img/symff.pdf}}
  \end{minipage}\hspace*{5mm}
\begin{minipage}{0.3\linewidth}
    \centering\scalebox{0.7}{\includegraphics{gkappa_img/symtf.pdf}}
  \end{minipage}
  \caption{Sites are equivalent, if the corrected rates of the third rule is twice the corrected rate of each other rule.}
  \label{fig:symmetric:rules}
\end{figure}

The rules are depicted in Fig.~\ref{fig:symmetric:rules}. We notice that each rule may be obtained from one another by swapping the sites in agents.  So we say that sites are equivalent in this set of rules. Equivalent sites may be used to induce forward and backward bisimulations \cite{buchholz_bisimulation,Feret_IJSI2013,Feret-MFPSXXVII,CAMPORESI201073,Feret201545} over the stochastic and the differential semantics of Kappa.

Let us consider two site names \ttt{x} and \ttt{y} in the signature of an agent type \ttt{A}.
A \emph{set of rules} is symmetric with respect to \ttt{x} and \ttt{y}, if for every two rules that may be obtained one from the other one by permuting the sites \ttt{x} and \ttt{y} in some agents of type \ttt{A}, their corrected rates is inversely proportional to their number of automorphisms.
In our example,  the set of rules is symmetric with respect to \ttt{x} and \ttt{y} only with the convention in which constant rates are kept as they are given, without any corrective factor. A \emph{valuation} from bio-molecular species to real numbers is symmetric with respect to \ttt{x} and \ttt{y}, if for every two bio-molecular species that can be obtained one from the other one by permuting the sites \ttt{x} and \ttt{y} in some agents of type \ttt{A}, the image of the two bio-molecular species by the valuation is inversely proportional to their number of automorphisms. Lastly an \emph{expression} over bio-molecular species is symmetric with respect to \ttt{x} and \ttt{y}, if and only if it takes the same values for every two symmetric valuations.

If the set of rules and the initial state of the model are symmetric with respect to two sites, ignoring the difference among these two sites in bio-molecular species induces a backward bisimulation (that is to say, the state of the system remains symmetric at every time \cite{buchholz_lump}). If the set of rules and every algebraic expression that occurs in rates or stoichiometric coefficients are symmetric, then ignoring the difference between these two sites in bio-molecular species induces a forward bisimulation (we can define the ODEs directly over the equivalence-classes of bio-molecular species \cite{buchholz_lump}).

The following option is available:
\begin{itemize}
  \item
The command line option \texttt{-{}-with-symmetries [ None | Backward | Forward ]} sets which kind of bisimulation is used to reduce the system of ordinary differential equations.
\end{itemize}

\subsection{The sub-tab \texttt{Model reduction}}

The sub-tab \texttt{Model reduction} gives access to more information about
potential model reduction.
\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kade_4.png}
\caption{\KaDE~ graphical interface - sub-tab \texttt{Model reduction}.}
\label{fig:kade:4}
\end{figure}

The following options are available:
\begin{itemize}
  \item The option \texttt{-{}-show-symmetries} itemizes the sites that are equivalent with respect to the rules of the models, with respect to the rules of the model and the initial state (backward bisimulation), and with respect to the rules of the models and the algebraic expressions (forward bisimulation).
  \item The command line option \texttt{-{}-with-symmetries [ None | Backward | Forward ]} sets which kind of bisimulation is used to reduce the system of ordinary differential equations.
\end{itemize}

\subsubsection{The sub-tab \texttt{Static analysis (Expert)}}

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{img/kade_5.png}
\caption{\KaDE~ graphical interface - sub-tab \texttt{Static analysis}.}
\label{fig:kade:5}
\end{figure}

The inference of equivalent sites is more precise when dead rules are discarded. Dead rules can be computed thanks to {\KaSa}. The sub-tab \texttt{Static analysis} allows the end-user to switch on/switch off abstract domains in order to tune the trade-off between accuracy and efficiency of  static analysis.

The following options are available:
\begin{itemize}
\item The option \verb?--(no-)views-domain? can be used to switch on/off the views domains.

\item The option \verb?--(no-)double-bonds-domain? can be used to switch on/off the analysis of potential double bonds between proteins.

\item The option \verb?--(no-)site-across-bonds-domain? can be used to switch on/off the analysis of the relations among the states of the sites in connected proteins.
\end{itemize}

\section{Tutorial}

Now we explain further how to use {\KaDE} to deal with the example of Sect.~\ref{sec:kade:ex}.
The model is described in the following Kappa file:
\lstinputlisting[language=Kappa]{kappa/sym.ka}

The rules of this models are depicted as follows:

\begin{center}
\begin{minipage}{0.49\linewidth}
    \centering\scalebox{0.85}{\includegraphics{gkappa_img/symtt.pdf}}
  \end{minipage}


\begin{minipage}{0.49\linewidth}
  \centering\scalebox{0.85}{\includegraphics{gkappa_img/symff.pdf}}
\end{minipage}


\begin{minipage}{0.49\linewidth}
    \centering\scalebox{0.85}{\includegraphics{gkappa_img/symtf.pdf}}
  \end{minipage}

\end{center}

We denote as $\gamma_1$, $\gamma_2$, and $\gamma_3$ the corrected rate constants of these rules. With the third convention, which roughly speaking consists in dividing rates per the number of automorphisms in the left hand side of rules, that are preserved in the right hand side, we have:
\begin{itemize}
  \item $\gamma_1 = \myfrac{k_1}{2}$;
  \item $\gamma_2 = \myfrac{k_2}{2}$;
  \item $\gamma_3 = k_3$.
\end{itemize}
Indeed, in the third rule, the mechanism makes a difference among the two agents. The non trivial automorphism in the left hand side is not preserved in the right hand side.


Rules $1$ and $2$ have two automorphisms, whereas rule $3$ has only one.
As a consequence, the rules are symmetric with respect to both sites if and only $2\cdot\myfrac{k_1}{2}=2\cdot\myfrac{k_2}{2}=k_3$, that is to say $k_1=k_2=k_3$.


We use the following command line to generate the ODE semantics in \textsc{Octave}:
\ITE{
\item[\$] \ttt{KaDe --rate-convention Biochemist sym.ka}}

By default, equivalent sites are not analysed and the \textsc{Octave} backend is used.

The result is dumped in the file \texttt{'ode.m'}, which  is editable. Moreover, each instruction is annotated with some information referring to the Kappa file. Variables are annotated by the corresponding name in the Kappa file. Initial species are annotated by Kappa expressions describing the corresponding bio-molecular species.


\lstset{numbers=none}

Integration parameters are defined as follows:
\ITE{
\item[\$] \ttt{grep -n -m 1 'tinit=' ode.m --after-context 8}}
\lstinputlisting[language=Octave]{generated_img/int_parameters.txt}

The variable \texttt{nodevar} gives the number of variables:
\ITE{
\item[\$] \ttt{grep -n -m 1 'nodevar=' ode.m}}
\lstinputlisting[language=Octave]{generated_img/n_var.txt}

The function \texttt{ode\_init} defines the list of variables and their initial concentration:
\ITE{
\item[\$] \ttt{grep -n -m 1 'function Init' ode.m --after-context 11 }}
\lstinputlisting[language=Octave]{generated_img/init.txt}
We notice that four variables encode the concentration of bio-molecular species and a special one accounts for time advance.

The function \texttt{dydt} defines the differential equations:
\ITE{
\item[\$] \ttt{grep -n -m 1 'function dydt' ode.m --after-context 38}}
\lstinputlisting[language=Octave]{generated_img/dydt.txt}

The function \texttt{obs} defines the observables:
\ITE{
\item[\$] \ttt{grep -n -m 1 'function obs' ode.m --after-context 12}}
\lstinputlisting[language=Octave]{generated_img/obs.txt}

The function \texttt{jac} provides the Jacobian (we omit it).

We now wonder whether the sites are equivalent or not. We use the following command line:
\ITE{
\item[\$] \ttt{KaDE --rate-convention Biochemist sym.ka --show-symmetries}}
The status of equivalent sites is described in the log:
\lstinputlisting[language=Octave]{generated_img/sym.txt}

The set of rules and the initial state are symmetric with respect to the pair of sites. This is not the case of the observable. Thus, only backward bisimulation may be used to reduce the system. Indeed, if we ignore the difference between sites \texttt{x} and \texttt{y}, we can no longer express the concentration of asymmetric dimers. This  excludes forward bisimulation. Backward bisimulations may still be used since the concentration of each species can be computed by from the overall concentration of its equivalence class,  since the concentration of two equivalent species are always inversely proportional to their number of automorphisms.

The command line:
\ITE{
\item[\$] \ttt{KaDe --rate-convention Biochemist sym.ka --with-symmetries Forward --output ode\_with\_fwd\_sym --output-plot data\_fwd.csv}}
gives the same model, without any reduction.

The command line:
\ITE{
\item[\$] \ttt{KaDe --rate-convention Biochemist sym.ka --with-symmetries Backward --output ode\_with\_bwd\_sym --output-plot data\_bwd.csv}}
reduces the system by ignoring the difference between sites \texttt{x} and \texttt{y}. This is done by replacing in each reaction product, every species by an arbitrary representative of its equivalence class, and in each algebraic expression, each species concentration by the product of its the concentration of its representative times the relative weight of this species in its equivalence class (which is constant and inversely proportional to its number of automorphisms.)

We notice that there are only $3$ variables remaining:
\ITE{
\item[\$] \ttt{grep -n -m 1 '\%\% variables' ode\_with\_bwd\_sym.m}}
\lstinputlisting[language=Octave]{generated_img/n_var_bwd.txt}
\ITE{
\item[\$] \ttt{grep -n -m 1 'function Init' ode\_with\_bwd\_sym.m --after-context 9 }}
\lstinputlisting[language=Octave]{generated_img/init_bwd.txt}
one for time advance, one for free \texttt{A}{}s, and one for dimers (no matter which sites are bound). {\KaDE} has gathered the three kinds of dimers into a single equivalence class (no matter with sites are bound).  For instance, in the following:
\ITE{
\item[\$] \ttt{grep --after-context 6 -n -m 1 'rule    : A(x,y), A(x,y) -> A(x!1,y), A(x,y!1)' ode\_with\_bwd\_sym.m }}
\lstinputlisting[language=Octave]{generated_img/rule_bwd.txt}
 the production of an asymmetric dimer, is replaced with the production of a dimer in which the bond is on both sites \texttt{y}.

Now we explain how the values of the obervavles are computed.
The code for the function \texttt{obs} is the following one:
\ITE{
\item[\$] \ttt{grep -n -m 1 'function obs' ode\_with\_bwd\_sym.m --after-context 12}}
\lstinputlisting[language=Octave]{generated_img/obs_bwd.txt}
 We are interested in asymmetric dimers only. We notice that their concentration is obtained by dividing the overall quantity of dimers by $4$. To understand why, we shall have a closer look at the meaning of each variable. As indicated here:
\ITE{
\item[\$] \ttt{grep -n -m 1 '\%\% variables' ode\_with\_bwd\_sym.m}}
\lstinputlisting[language=Octave]{generated_img/convention_bwd.txt}
the convention is to count in number of embeddings. Thus the total number of dimers is $\frac{y(2)}{2}$. Then half of them only is an asymmetric dimer, which gives $\frac{y(2)}{4}$.

Let us check the soundness of our tools, by integrating our three  ODEs systems.

Firsly we define the file \texttt{plot.gplot} as follows:
\begin{lstlisting}[language=Gnuplot]
set xlabel 'Asymmetric dimer concentration'
set ylabel 'CPU time (s.)'
set datafile separator ','
set title 'Initial model'
set term png
set output 'plot.png'
set xrange [0:1]
set yrange [0.0:40.]
set output 'plot.png'
plot 'data.csv' using 1:2 w l
\end{lstlisting}
the file \texttt{plot\_fwd.gplot} as follows:
\begin{lstlisting}[language=Gnuplot]
set xlabel 'Asymmetric dimer concentration'
set ylabel 'CPU time (s.)'
set datafile separator ','
set title 'reduced model (fwd)'
set term png
set output 'plot_fwd.png'
set xrange [0:1]
set yrange [0.0:40.]
set output 'plot_fwd.png'
plot 'data_fwd.csv' using 1:2 w l
\end{lstlisting}
and the file \texttt{plot\_bwd.gplot} as follows:
\begin{lstlisting}[language=Gnuplot]
set xlabel 'Asymmetric dimer concentration'
set ylabel 'CPU time (s.)'
set datafile separator ','
set term png
set title 'Reduced model (bwd)'
set output 'plot_bwd.png'
set xrange [0:1]
set yrange [0.0:40.]
set output 'plot_bwd.png'
plot 'data.csv' using 1:2 w l
\end{lstlisting}

Then we can integrate our three differential systems and plot their respective  solutions thanks to the following command lines:
\ITE{
\item[\$] \ttt{octave ode.m}
\item[\$] \ttt{octave ode\_with\_fwd\_sym.m}
\item[\$] \ttt{octave ode\_with\_bwd\_sym.m}
\item[\$] \ttt{gnuplot plot.gplot}
\item[\$] \ttt{gnuplot plot\_fwd.gplot}
\item[\$] \ttt{gnuplot plot\_bwd.gplot}}

We obtain the following plots:
\begin{figure}[htp]
\centering  \begin{minipage}{0.35\linewidth}
   \scalebox{0.35}{\includegraphics{img/plot.png}}
\end{minipage}
\caption{Initial model (without reduction).}
\end{figure}

\begin{figure}[htp]
\centering\begin{minipage}{0.35\linewidth}
  \scalebox{0.35}{\includegraphics{img/plot_fwd.png}}
\end{minipage}
\caption{Reduced model (fwd bisimulation).}
\end{figure}

\begin{figure}[htp]
\centering\begin{minipage}{0.35\linewidth}
  \scalebox{0.35}{\includegraphics{img/plot_bwd.png}}
\end{minipage}\caption{Reduced model (bwd bisimulation).}
\end{figure}

\chapter{Frequently asked questions}
\section*{Simulation hangs after a while}
If the progress bar seems stalled, it does not necessarily mean that the simulation is blocked. In particular when a simulation is triggered with a \emph{time} limit (\ttt{-l} option of the command line) it might only indicate that the bio clock is stalled while computation events still occur. Recall that the average (bio) time one has to wait in order to apply a rule is $1/A$, where $A$ is the sum of all the rule activities (which is equal to the number of instances that a rule has, times its kinetic rate). Whenever the number of occurrences of a rule grows too fast (if new agents are created during the simulation for instance), or if the kinetic rate of a rule is defined by a function that grows rapidly, the average time increment might tend to 0 and if it remains so for a while, it will block the progress bar whose advance is proportional to the bio time \ttt{[T]}.

In order to make sure that \KaSim~is not incorrectly blocked you may wish to plot the event clock against time clock using the observable \ttt{\%obs: {\textquotesingle}events{\textquotesingle} [E]} or run the simulation using an event limit (\ttt{-e} option of the command line) instead of a time limit.

\section*{What do null events mean, why do I have any?}

Using null events\index{null event} is a way for \KaSim~to compensate for some over approximation it is doing, in order to deal with large simulations more efficiently. They usually do not impact significantly the performances of the simulator, unless the model contains rules using the special notation to deal with ambiguous molecularity (see Section~\ref{sec:ambiguous}). With pure Kappa rules, the ratio $r$ of null event over productive ones (that you can track using the observable \ttt{\%obs: {\textquotesingle}r{\textquotesingle}  [E-]/[E]}) should tend to 0 when models have a lot of agents.

\section*{No data points are generated}
Make sure you have \ttt{\%obs} or \ttt{\%plot} instructions in your KF\index{Kappa file}. Also make sure to use a reasonable value for the \ttt{-p} option in the command line to tell KaSim how often you wish to have points on your curves.

\section*{Too many instances of an observable}
The value of a Kappa expression $E$  is equal to the number of embeddings\index{embedding} it has in the current mixture\index{mixture} $M$. Embeddings are maps from agents in $E$  to agents in $M$. If $E$ has symmetries then every permutation of $E$ will be counted as a new embedding. For instance let $E=$\ttt{A(x[1]),A(x[1])}  and let $M=$\ttt{A(x[1],y\{p\}[.]),A(x[1],y\{u\}[.])}.
\KaSim~will count two instances of $E$ in $M$: the one mapping the first \ttt{A} of $E$ to the first \ttt{A} of $M$ and the one mapping the first \ttt{A} of $E$ to the second \ttt{A} of $M$.

%\section*{The computed influence map is incorrect, it misses some activation or has too much of them}
%The influence map\index{influence map} computed by \KaSim~contains relations that are computed on side effect free rules only. It is likely that a missing activation is due to a side effect that is not taken into account. If the influence map shows an activation between rule $r$ and $s$ that is never possible with a given model, just remember that activation computation implies that \emph{there exists} a context in which applying rule $r$ will create a new instance of rule $s$. This context might simply never be realized with the given rules or initial conditions.

\section*{Value \ttt{nan} in the data file\index{data file} at the end of the simulation}
The value \ttt{nan} means "Not a Number". It is generated when a plotted variable is infinite. Make sure this variable is not divided by zero at some point.

\bibliographystyle{plain}
\bibliography{fmb,concur,static_analyses}

\printindex

\end{document}
%%% Local Variables:
%%% ispell-local-dictionary: "british"
%%% End:
